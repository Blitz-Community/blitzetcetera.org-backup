		Общая часть

Решил написать статейку для людей, которые непременно хотят научиться писать свои собственные Dll'ки. Объектом для написания выбран PureBasic, за его скорость, простоту и функцинальность. Для начала хотелось бы сделать экскурс в наиболее часто перeдаваемые данные из блица в пурик и обратно.

Целое 4-байтное число. Лежит в пределах от -2147483647 до 2147483647. В пурике -Long (в коде как a.l), в блице Integer (в коде как a%). Если для переменной не указан тип, то автоматически назачается этот. Например, a%=68132
4-байтное число с плавающей точкой. Используется для дробных чисел. В пурике -Float(в коде как a.f), в блице тоже Float (в коде как a#). Например, a.f=0.15
Строка, для записи строковых переменных.В пурике - String (в коде как a.s), в блице тоже String (в коде как a$). Например, stroka.s="World"

		Целые числа

Для начала напишем простейшую функцию, которая складывает два целых числа. В блице это выглядит так : FunkciaSlojeniya%(a%,b%) - то есть задается два параметра a% и b%, а функция возвращает результат их сложения. Пишем в пурике основу нашей dll функции:

ProcedureDLL FunkciaSlojeniya(a,b) 
c=a+b
ProcedureReturn c
EndProcedure

Разберемся поподробнее. ProcedureDLL - объявляет что сейчас будет функция для dll'ки. Далее FunkciaSlojeniya - название нашей функции. Нужно чтобы оно не совпадало с уже существующими блица, пурика и т.д. чтобы не вызвать ошибок.Параметры (a,b) - значит что в функцию направляется два числа. 'c=a+b' складываем два числа и результат помещаем в переменную с. 'ProcedureReturn c' - функция возвращает переменную 'c'. 'EndProcedure' - закрываем dll функцию. Так как мы нигде не указывали тип для переменных (см выше), то для них автоматически назначен тип Long (Integer)

Сохраняем файл MyLib.pb. Затем переходим в меню Compiler->Compiler Options. Находим строку Executable Format и выбираем SharedDll. Затем ОК. Это значит что когда будем компиллировать, то на выходе получится не exe файл , а dll библиотека. Если будете делать Exe'шник, то не забудьте поменять обратно.

Делаем саму dll'ку: меню Compiler->Create Executable. Сохраняем в папку Bltz3d\userlibs под именем mylib.dll.
Теперь внедряем её в блиц. В папке Bltz3d\userlibs создаем текстовый файл "MyLib.decls" следующего содержания:

.lib "mylib.dll"
FunkciaSlojeniya%(a,b):"FunkciaSlojeniya"

В первой строке указываем название dll файла. Далее расписываются все функции, которые нужно включить в блиц. На каждую функцию приходится по одной строке. Строка разбивается на две части двоеточием. До двоеточия - это представление в блице, а после - это то как мы назвали функцию в пурике. Причем название в блице может отличаться от названия в dll'ке - сделано для удобства. В первой части строки после названия функции пишем формат возвращаемых данных - в данном случае это целое число, поэтому пишем %. Здесь обязательно писать формат, даже если он Long (Integrer).

Запускаем блиц и проверяем работу. Запускаем код:
Print FunkciaSlojeniya(5,10)
И в результате на экране 15 (то есть пять плюс десять) - функция работает.

		Дробные числа

Теперь давайте напишем функцию, которая использует переменные типа Float. Пускай функция имеет три параметра, перемножает первые два числа и делит на третье. Пишем в пурике.

ProcedureDLL.f FunkciaDlyaFloatov(a.f, b.f, c.f) 
d.f=(a*b)/c
ProcedureReturn d
EndProcedure

Кое-что изменилось: у ProcedureDLL появилось окончание .f , которое означает, что функция возвращает данные типа Float. У параметров появились такие же окончания. В строчке 'd.f=(a*b)/c' для переменной d тоже указывается тип .f, но для остальных его уже не надо писать, так как они уже объявлены в строке с парамтерами. При обращении к ним в последующем писать тип не обязательно. В строке 'ProcedureReturn d' у переменной d типа уже не указан.

Теперь открываем MyLib.decls  и добавляем в него строку 

FunkciaDlyaFloatov#(a#,b#,c#):"FunkciaDlyaFloatov"

FunkciaDlyaFloatov# - означается что функция возвращает тип данных Float. А (a#,b#,c#) устанавливает для параметров тип Float. Сохраняем, запускаем блиц и запускаем строку:
Print FunkciaDlyaFloatov(2,5,4)
На экране печатается 2.5 - то есть (2*5)/4 = 2.5 - все верно!

		Строковая функция

Теперь замутим что-нибуль со строковыми переменными. Напишем простейшую функцию, которая добавляет к строке случайное число.

ProcedureDLL.s FunkciaStokaPlusChislo(stroka.s, chislo.l)
stroka.s=stroka.s+Str(Random(chislo))
ProcedureReturn stroka
EndProcedure

ProcedureDLL.s - функция возвращает строковый тип данных. Stroka.s - строка, к которой будет прибавляться случайное число. Chislo - диапазон, до которого будет генерироваться случайное число. Обратите внимание что не указан тип переменной, и автоматически выбран тип Long (Integer)


Теперь делаем запись MyLib.decls

FunkciaStokaPlusChislo$(stroka$, chislo%):"FunkciaStokaPlusChislo"

FunkciaStokaPlusChislo$ - функция возвращает строковый тип данных. Параметры stroka$ - string, chislo% - Long(Integer). Проверяем в блице:

Print FunkciaStokaPlusChislo("Random number to 16 is ",16)
Print FunkciaStokaPlusChislo("Random number to 16 is ",16)
Print FunkciaStokaPlusChislo("Random number to 16 is ",16)
Print FunkciaStokaPlusChislo("Random number to 16 is ",16)
Print FunkciaStokaPlusChislo("Random number to 16 is ",16)

Должны напечататься пять строк "Random number to 16 is "  и после каждой из них случайное целое число от нуля до шестнадцати

		Банки памяти

Теперь пару слов о банках памяти. Для работы с ними в пурике используются специальные указатели, которые начинаются с *, например *bank. Напишем функцию, которая считывает переменную типа Float с указанного адреса со смещением Offset. 

ProcedureDLL.f SamplePeekF(*bank,offset)
ProcedureReturn PeekF(*bank+offset)
EndProcedure

Думаю что все понятно. Банк обозначен звездочкой как *Bank. В MyLib.decls банк обозначется звездочкой в конце (!), а не в начале.

SamplePeekF#(Bank*,offset):"SamplePeekF"

В блиц загоняем этот код. Надеюсь все понятно:

bank=CreateBank(12)
PokeFloat(bank,0,0.128)
PokeFloat(bank,4,32.9)
PokeFloat(bank,8,213.75)
Print "Peek floats from bank "
Print SamplePeekF(bank,0)
Print SamplePeekF(bank,4)
Print SamplePeekF(bank,8)

		Entity

В памяти блица многие объекты хранятся тоже в виде банков памяти. Структуру их можно посмтотреть на форуме (http://blitz.pp.ru/forum/showthread.php?s=&threadid=203). Особенность работы с этими данными - в деклсе банк ентити нужно обозначать не как банк, а как простое Long (Integer) число. Сделаем простенькую функцию, которая получает координату X Entity. Float c координатой X находится в смещении 64 от хендла ентити. Итак сделаем специальную функцию, аналог блиц функции EntityX: 

ProcedureDLL.f FunkciyaEntityX(*entity)
ProcedureReturn PeekF(*entity+64)
EndProcedure

В деклсе напишем (entity пишем без звездочки):

FunkciyaEntityX#(entity):"FunkciyaEntityX"

А в блице:

Graphics3D 400,300,0,2 
pivot=CreatePivot()
PositionEntity pivot,20.125,0,0
Print "FunkciyaEntityX "
Print FunkciyaEntityX(pivot)

Вот и все. Теперь вы сами можете сами написать свою DLL.

По всем замечаниям и предложениям обращаться на e-mail.

MadMedic | MadMedic@rambler.ru | MadMedic.by.ru