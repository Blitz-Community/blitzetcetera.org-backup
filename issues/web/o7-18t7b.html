<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru" dir="ltr">	
<!-- Mirrored from localhost/index.php/%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM by HTTrack Website Copier/3.x [XR&CO'2007], Mon, 12 Nov 2007 11:20:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
<head>		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />				<meta name="keywords" content="Создание ландшафтов с применением алгоритма ROAM,MadMedic" />
		<link rel="shortcut icon" href="http://blitzetcetera.org/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="http://blitzetcetera.org/opensearch_desc.php" title="Blitz Et Cetera (Русский)" />
		<title>Создание ландшафтов с применением алгоритма ROAM — Blitz Et Cetera</title>		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "bvih5rde.css?63"; /*]]>*/</style>		<link rel="stylesheet" type="text/css" media="print" href="gcxktlm6.css?63" />		<link rel="stylesheet" type="text/css" media="handheld" href="zumsslq_.css?63" />		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins/OfflineNew/IE50Fixes.css?63";</style><![endif]-->		<!--[if IE 5.5000]><style type="text/css">@import "/skins/OfflineNew/IE55Fixes.css?63";</style><![endif]-->		<!--[if IE 6]><style type="text/css">@import "/skins/OfflineNew/IE60Fixes.css?63";</style><![endif]-->		<!--[if IE 7]><style type="text/css">@import "/skins/OfflineNew/IE70Fixes.css?63";</style><![endif]-->		<!--[if lt IE 7]><script type="text/javascript" src="/skins/common/IEFixes.js?63"></script>		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->		<script type= "text/javascript">/*<![CDATA[*/
var skin = "OfflineNew";
var stylepath = "/skins";
var wgArticlePath = "/index.php/$1";
var wgScriptPath = "";
var wgServer = "http://blitzetcetera.org/";
var wgCanonicalNamespace = "";
var wgCanonicalSpecialPageName = false;
var wgNamespaceNumber = 0;
var wgPageName = "Создание_ландшафтов_с_применением_алгоритма_ROAM";
var wgTitle = "Создание ландшафтов с применением алгоритма ROAM";
var wgAction = "view";
var wgArticleId = "1696";
var wgIsArticle = true;
var wgUserName = null;
var wgUserGroups = null;
var wgUserLanguage = "ru";
var wgContentLanguage = "ru";
var wgBreakFrames = false;
var wgCurRevisionId = "3462";
/*]]>*/</script>
		<script type="text/javascript" src="2nq-6cel.js?63"><!-- wikibits js --></script>		<script type="text/javascript" src="http://blitzetcetera.org/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>		<style type="text/css">/*<![CDATA[*/
@import "http://blitzetcetera.org/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
@import "http://blitzetcetera.org/index.php?title=MediaWiki:OfflineNew.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
@import "http://blitzetcetera.org/index.php?title=-&amp;action=raw&amp;gen=css&amp;maxage=18000";
/*]]>*/</style>		<!-- Head Scripts -->	</head><body  class="mediawiki ns-0 ltr page-Создание_ландшафтов_с_применением_алгоритма_ROAM">	<div id="globalWrapper">	<div id="logocontainer">		<table align="center">		  <tr>				<td id="blitzetclogo">				</td>			</tr>		</table>	</div>	<div id="magbar">	Журнал о программированнии на языках Blitz3D, BlitzMax, BlitzPlus	</div>		<div id="column-content">	<div id="content">		<a name="top" id="top"></a>				<div id="bodyContent">		<table cellspacing=0 cellpadding=0 width=100%>			<tr>			  <td class="leftside">				</td>				<td class="sheetbody">					<h1 class="sheet">Создание ландшафтов с применением алгоритма ROAM</h1>			<h3 id="siteSub">Материал из Blitz Et Cetera.</h3>			<div id="contentSub"></div>			<!-- start content -->			<table id="toc" class="toc" summary="Содержание"><tr><td><div id="toctitle"><h2>Содержание</h2></div>
<ul>
<li class="toclevel-1"><a href="#.D0.92.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D0.B5"><span class="tocnumber">1</span> <span class="toctext">Введение</span></a></li>
<li class="toclevel-1"><a href="#.D0.A1.D1.83.D1.89.D0.BD.D0.BE.D1.81.D1.82.D1.8C_ROAM_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.B0"><span class="tocnumber">2</span> <span class="toctext">Сущность ROAM метода</span></a>
<ul>
<li class="toclevel-2"><a href="#.D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D0.BD.D1.8F.D1.82.D0.B8.D1.8F"><span class="tocnumber">2.1</span> <span class="toctext">Основные понятия</span></a></li>
<li class="toclevel-2"><a href="#.D0.94.D0.B5.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.82.D1.80.D0.B5.D1.83.D0.B3.D0.BE.D0.BB.D1.8C.D0.BD.D0.B8.D0.BA.D0.BE.D0.B2"><span class="tocnumber">2.2</span> <span class="toctext">Деление треугольников</span></a></li>
<li class="toclevel-2"><a href="#.D0.91.D0.B8.D0.BD.D0.B0.D1.80.D0.BD.D0.BE.D0.B5_.D0.B4.D0.B5.D1.80.D0.B5.D0.B2.D0.BE"><span class="tocnumber">2.3</span> <span class="toctext">Бинарное дерево</span></a></li>
<li class="toclevel-2"><a href="#Diamond_split"><span class="tocnumber">2.4</span> <span class="toctext">Diamond split</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#.D0.9C.D0.BE.D0.B8_.D0.B4.D0.BE.D0.B1.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B2_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4"><span class="tocnumber">3</span> <span class="toctext">Мои добавления в метод</span></a></li>
<li class="toclevel-1"><a href="#.D0.9F.D1.80.D0.B0.D0.BA.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B0.D1.8F_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">4</span> <span class="toctext">Практическая реализация</span></a></li>
<li class="toclevel-1"><a href="#.D0.94.D0.B0.D0.BB.D1.8C.D0.BD.D0.B5.D0.B9.D1.88.D0.B8.D0.B5_.D0.BE.D0.BF.D1.82.D0.B8.D0.BC.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8"><span class="tocnumber">5</span> <span class="toctext">Дальнейшие оптимизации</span></a></li>
<li class="toclevel-1"><a href="#.D0.A1.D0.BF.D0.B8.D1.81.D0.BE.D0.BA_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D0.BE.D0.B9_.D0.BB.D0.B8.D1.82.D0.B5.D1.80.D0.B0.D1.82.D1.83.D1.80.D1.8B"><span class="tocnumber">6</span> <span class="toctext">Список использованной литературы</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "показать"; var tocHideText = "убрать"; showTocToggle(); } </script>
<a name=".D0.92.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D0.B5"></a><h2><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=1" title="Править секцию: Введение">править</a>]</span> <span class="mw-headline"> Введение </span></h2>
<p>Алгоритм ROAM (Real-time Optimally Adapting Meshes), основанный на структуре "Бинарное дерево треугольников", представляет Duchaineau et.al. и был реализован в движке Tread Marks (<a href="http://www.treadmarks.com/" class="external free" title="http://www.TreadMarks.com" rel="nofollow">http://www.TreadMarks.com</a>). Я не претендую на 100% достоверную передачу алгоритма, но постарался оптимизировать по своему усмотрению и добавил некоторые моменты, которые нельзя реализовать штатными средствами в блице (например, отрисовка группы треугольников). Добавленные или измененные мною моменты выделены в статье. Хотелось бы сразу отметить что пример не показывает обновляющийся в реалтайме террайн, а просто демонстрирует механизм работы алгоритма. Скорость блица не позволит сделать террайн обновляющийся каждый кадр быстрее чем встроенный в Блиц3д. Алгоритм ROAM довольно труден для восприятия и поэтому я постарался максимально подробно объяснить каждое действие и максимально иллюстрировать документ наглядным материалом.
</p><p><br />
</p>
<a name=".D0.A1.D1.83.D1.89.D0.BD.D0.BE.D1.81.D1.82.D1.8C_ROAM_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.B0"></a><h2><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=2" title="Править секцию: Сущность ROAM метода">править</a>]</span> <span class="mw-headline"> Сущность ROAM метода </span></h2>
<a name=".D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D0.BD.D1.8F.D1.82.D0.B8.D1.8F"></a><h3><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=3" title="Править секцию: Основные понятия">править</a>]</span> <span class="mw-headline"> Основные понятия </span></h3>
<p>Для построения ландшафта нам необходима карта высот. В нашем случае это будет массив вещественных чисел <b>HeightMap#(TerrainSize,TerrainSize)</b> , считанный из изображения. Ключевым понятием в методе ROAM является прямоугольный треугольник. Давайте рассмотрим его структуру:
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_0.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_0.jpg" src="m43ub0nd.jpg" width="400" height="378" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 0
</td></tr></table>
<p>Рассматриваемый треугольник образован тремя вершинами: левый вертекс (v0), вертекс верхушки (v1) и правый вертекс (v2). На середине расстояния между боковыми точками поставим точку и назовем её центральной точкой (vC). Если провести линию от вертекса верхушки к центральной точке, то мы разделим исходный треугольник на два дочерних: левый и правый потомки. Исходный треугольник при этом будет являться для них родительским. Каждый из полученных треугольников можно разделить точно так же. Таким образом, деля треугольники до определенного уровня мы можем детализировать ландшафт настолько насколько это необходимо:
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_1.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_1.jpg" src="hw156hee.jpg" width="500" height="230" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 1
</td></tr></table>
<p>Важным моментом является понятие соседа основания (<i>base neighbor</i>) - это тот треугольник, который своим основанием прилежит к основанию рассматриваемого треугольника.
</p><p><br />
</p>
<a name=".D0.94.D0.B5.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.82.D1.80.D0.B5.D1.83.D0.B3.D0.BE.D0.BB.D1.8C.D0.BD.D0.B8.D0.BA.D0.BE.D0.B2"></a><h3><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=4" title="Править секцию: Деление треугольников">править</a>]</span> <span class="mw-headline"> Деление треугольников </span></h3>
<p>Теперь рассмотрим, по какому принципу происходит деление родительского треугольника на дочерние. Чтобы узнать необходимо ли нам  разбивать треугольник, нужно определить насколько форма описываемвая треугольником отличается от  фактической высоты по HeightMap'е. Рассмотрим треугольник. В качестве эталонной точки берется центральная точка. Погрешность вычисляется по очень простой формуле:
</p><p><b>погрешность=Abs((hLeft+hRight)/2-hCenter)</b>
</p><p><b>hLeft,hRight</b> - это высота по карте высот в точках правого и левого вертекса.
</p><p><b>hCenter</b> - это высота по карте высот центральной точке
</p><p><b>(hLeft+hRight)/2</b> - интерполированная высота над центральной точкой
</p><p>Например, возьмем <i>hLeft=15.0</i>, <i>hRight=25.0</i> и <i>hCenter=23.0</i>. По формуле погрешность равна <i>Abs((15+25)/2-23)=Abs(20-23)=3</i>. Чтобы определить является ли погрешность достаточной для деления, нам понадобится переменная, назовём её <b>RoamMaxHeightError</b>. Её значение характеризует максимально допустимую разницу высот между фактической и желаемой. Чем меньше её значение, тем больше ландшафт будет соответствовать действительности и тем больше рисовать полигонов. И наоборот чем больше её значение, тем грубее будет ландшафт и тем меньше полигонов занимать. Если принять <i>RoamMaxHeightError=5</i>, то треугольник дальше разбиваться не будет, т.к. <i>погрешность&lt;RoamMaxHeightError (3&lt;5)</i>. Если же принять значение <i>RoamMaxHeightError=2</i>, то треугольник будет разбит, т.к. погрешность превышает максимально допутимый уровень погрешности (3&gt;2). Для примера покажу несколько рендеров ландшафта 1024*1024 с разным значением <i>RoamMaxHeightError</i>. Высота ландшафта от -40.96 до 40.96.
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_2.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_2.jpg" src="33ykz89x.jpg" width="600" height="165" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 2
</td></tr></table>
<table border="1" align="center">
<tr>
<td>Рисунок
</td><td>RoamMaxHeightError
</td><td>Количество полигонов
</td></tr>
<tr>
<td>2.1
</td><td>10.0
</td><td>323
</td></tr>
<tr>
<td>2.2
</td><td>2.0
</td><td>5032
</td></tr>
<tr>
<td>2.3
</td><td>0.75
</td><td>25348
</td></tr></table>
<table align="center">
<tr>
<td>Таблица 0
</td></tr></table>
<p><br />
Здесь наглядно видно преимущество метода: треугольники не тратятся на отрисовку относительно плоских поверхностей, а более детально обрабатывают выпуклые поверхности.
</p><p><br />
</p>
<a name=".D0.91.D0.B8.D0.BD.D0.B0.D1.80.D0.BD.D0.BE.D0.B5_.D0.B4.D0.B5.D1.80.D0.B5.D0.B2.D0.BE"></a><h3><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=5" title="Править секцию: Бинарное дерево">править</a>]</span> <span class="mw-headline"> Бинарное дерево </span></h3>
<p>Теперь разберемся, почему алгоритм основан на структуре "Бинарное дерево треугольников".  Как видно из предыдущей картинки каждый треугольник имеет свой индивидуальный номер. Левому потомку присваивается номер <b>(родитель&lt;&lt;1)</b>, а правому <b>(родитель&lt;&lt;1)+1</b>.
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_3.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_3.jpg" src="t1q2l5go.jpg" width="500" height="181" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 3
</td></tr></table>
<p>Структура ландшафта в памяти компьютера представлена банком памяти, при этом каждому треугольнику соответствует байт памяти, а его адрес соответствует номеру треугольника. Значение байта представляет будет ли делиться треугольник. Например, значение 1 обозначает, что текущий треугольник будет разделен на два дочерних, а значение 0 что не будет. Бинарное дерево даёт преимущество в том,  что адрес каждого треугольника очень легко вычислить, используя операции байтового сдвига. Сдвиг вправо дает возможность найти родителя:
</p>
<dl><dt>parent = Tri Shr  1
</dt></dl>
<p>а сдвиг влево потомков:
</p>
<dl><dt>LeftChild =Tri Shl 1
</dt></dl>
<dl><dt>RightChild =(Tri Shl 1)+1;
</dt></dl>
<p>Таким образом алгоритм построения ландшафта складывается из двух частей:
</p>
<ol><li> Сначала мы рекурсивно обходим треугольники, проверяя погрешность высоты. Если погрешность превышает <i>RoamMaxHeightError</i> то записываем в соответствующий байт в банке памяти 1 и проверяем погрешность высоты для его потомков (для них аналогично). Если же погрешность укладывается в <i>RoamMaxHeightError</i> то записываем в соответствующий байт 0 и переходим к следующему шагу.
</li><li> Теперь строим меш ландшафта по созданному нами дереву.
</li></ol>
<p><br />
</p>
<a name="Diamond_split"></a><h3><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=6" title="Править секцию: Diamond split">править</a>]</span> <span class="mw-headline"> Diamond split </span></h3>
<p>Однако даже в таком простом и наглядном алгоритме есть одна проблема. Давайте рассмотрим на примере:
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_4.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_4.jpg" src="096nivay.jpg" width="300" height="197" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 4
</td></tr></table>
<p>У нас есть треугольник. Рассмотрим процесс его деления по шагам.
</p>
<ol><li> Имеется треугольник 1. Определяем погрешность, допустим она больше текущего <i>RoamMaxHeightError</i>. Поэтому разделяем его на два дочерних: 2 и 3
</li><li> Рассматриваем  треугольники 2 и 3. Допустим погрешность в треугольнике 3 не больше <i>RoamMaxHeightError</i> и поэтому дальше его не делим. Теперь допустим, что погрешность в треугольнике 2 достаточна для его деления на треугольники 4 и 5. 
</li><li> Треугольник 3 не имеет потомков, его структура дальше не просчитывается. Теперь рассматриваем  треугольники 4 и 5.  Допустим, дальше треугольник 5 остается без изменений, а 4 делится на 8 и 9.
</li><li> В итоге мы имеем поверхность, состоящую из треугольников 3,5,8,9. Обратим внимание на стык треугольников 3, 8 и 9. Как видно 8 и 9 представляют участки с большей детализацией и 3 с меньшей. Из за этого на поверхности ландшафта будут образовываться так называемые трещины. Вот как они выглядят:
</li></ol>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_5.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_5.jpg" src="096nivay-2.jpg" width="400" height="105" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 5
</td></tr></table>
<p>Описанная ситуация решается довольно просто. Помните, в описании структур мы говорили и понятии "соседа основания "? Для того чтобы устранить зазор в поверхности необходимо разделить и соседа основания. В оригинальном документе два прилежащих основаниями треугольника называют Diamond, из-за похожести его на алмаз или бриллиант. А операция по их делению называется Split on a diamond, то есть его разделение. После того как сосед основания будет разделен, алгоритм переходит на его родителя и его соседа основания. И так до тех пор, пока не встретятся уже оба разделенных треугольника.
</p>
<a name=".D0.9C.D0.BE.D0.B8_.D0.B4.D0.BE.D0.B1.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B2_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4"></a><h2><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=7" title="Править секцию: Мои добавления в метод">править</a>]</span> <span class="mw-headline"> Мои добавления в метод </span></h2>
<p>Во первых, форма треугольника не совсем соответствует привычной квадратной форме ландшафта. В оригинальной статье не было приведено оптимального составления квадрата из треугольников. Максимально удобная форма для создания ландшафта это, на мой взгляд, два треугольника приложенные своими основаниями:
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_6.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_6.jpg" src="aif_kulh.jpg" width="602" height="158" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 6
</td></tr></table>
<p>Таким образом, создается две структуры в памяти, соответствующие двум треугольникам. В таком случае соседом основания из первой структуры может стать треугольник из второй структуры, что непременно мы учтем в дальнейшем (например, треугольники 1-1, 5-6, 22-25 и т.д.). Условно назовём эти треугольники разными "ветками" (branch).
</p><p>В оригинале для обозначения треугольника в памяти используется довольно обширная структура, содержащая ссылку на потомков треугольника, его родителя, соседа основания, соседей основания потомков. В моей версии из этой структуры остается два числа: ссылка на соседа основания и его флаг, показывающий является ли сосед основания из текущей структуры или из другой. В памяти объявим массивы: <b>BaseNeighbor(maxtriangles)</b> и <b>BaseNeighborFlag(maxtriangles)</b>. Например, соседом треугольника 4 является 7 из той же структуры, т.е. <i>BaseNeighbor(4)=7</i> и <i>BaseNeighborFlag(4)=0</i>. Или другой пример соседом треугольника 21 является треугольник 26 из другой структуры, тогда <i>BaseNeighbor(21)=26</i> и <i>BaseNeighborFlag(21)=1</i>.
</p><p>Следующей проблемой стал быстрый и четкий алгоритм поиска соседа основания для каждого треугольника.  Можно конечно было скинуть эти данные на жесткий диск, но 5 мегабайт бинарных несжимаемых данных (для террайна 1024*1024) принесли бы мало радости. Результатом детального исследования стали следующие выводы:
</p><p>1.  Если уровень первый, то устанавливаем в качестве соседа основания треугольник 1  и флаг 1: <i>BaseNeighbor(1)=1</i> и <i>BaseNeighborFlag(1)=1</i>.
</p><p>2.  Если треугольник является левым потомком родителя и его родитель является левым потомком прародителя, то базовым соседом искомого треугольника является правый потомок правого потомка прародителя. Посмотрите на рисунок 7. Возьмем, например, номер 12. он левый потомок шестого, а шестой - левый потомок третьего. Значит соседом 12 будет правый потомок правого потомка от 3, т.е. 15. Проверимся по рисунку 1 - это правда. Аналогичное правило действует наоборот если идти от правого потомка правого потомка. Все найденные таким образом потомки получают флаг 0, т.к. находятся в одной структуре.
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_7.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_7.jpg" src="mll_p3pp-2.jpg" width="323" height="114" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 7
</td></tr></table>
<p>3.  Если найти прародителя не удается (второй уровень), то такие треугольники не имеют базовых соседей.
</p><p>4.  Если треугольник является правым потомком родителя, в то же время как родитель является левым потомком прародителя, в этом случае мы смотрим на прародителя. Если у него нет соседа основания, то и искомый треугольник не имеет соседа основания. Если же прародитель имеет соседа основания, то соседом основания искомого треугольника будет левый потомок правого потомка соседа основания прародителя.
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_8.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_8.jpg" src="74m70vbg.jpg" width="295" height="128" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 8
</td></tr></table>
<p>Также полезно будет ввести понятие наименьшей детализации, дабы не допускать слишком грубых огрехов в создании ландшафта. На практике это значит, что если размер треугольника меньше определенной цифры, то треугольник надо разбивать. Алгоритм может пропустить довольно большие перепады высоты, но занимающие небольшую площадь, т.к. в них может не попасть центральная точка и провериться погрешность высоты. Посмотрим на следующую картинку:
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_9.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_9.jpg" src="g8p36dwr-2.jpg" width="400" height="150" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 9
</td></tr></table>
<p>Оба ландшафта построены с одинаковым значением <b>RoamMaxHeightError=5</b>. На первый ландшафт ушло 1426 поликов, а на второй  758. При этом на первом видно несколько довольно крупных горок, которые алгоритм упустил из виду во втором случае. Обязательная прорисовываемая сетка с крупными тайлами хоть и увеличивает количество полигонов, но значительно повышает качество отображения. Определим минимальный размер тайла, из которых будет составлен террайн, допустим
</p>
<dl><dt> MinimumTileSize=64
</dt></dl>
<p>Тогда минимальный уровень найдем как:
</p>
<dl><dt>MinTileSizeLevel=2^(RoamTerrainWidth/MinimumTileSize)
</dt></dl>
<p>Все треугольники, номер которых меньше этого значения будут обязательно прорисованы.
</p><p><br />
</p>
<a name=".D0.9F.D1.80.D0.B0.D0.BA.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B0.D1.8F_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F"></a><h2><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=8" title="Править секцию: Практическая реализация">править</a>]</span> <span class="mw-headline"> Практическая реализация </span></h2>
<p>Наконец-то мы пришли к самому интересному. Для начала объявим графический режим определим переменные, определяющие детализацию ландшафта:
</p>
<div class="bb" style="font-family: monospace;background-color:#FFFFFF;border:1px dashed #CCCCCC;padding:10px;background-color:#225588;color:#FFFFFF;border:1px solid #003040;padding:10px;"><span style="color: #aaffff; font-weight: bold;">Graphics3D</span> <span style="color: #33ffdd;">640</span>,<span style="color: #33ffdd;">480</span>,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">2</span><br />
<p><span style="color: #aaffff; font-weight: bold;">Global</span> RoamMaxHeightError#=<span style="color: #33ffdd;">5.0</span><br />
</p>
<span style="color: #aaffff; font-weight: bold;">Global</span> MinimumTileSize=<span style="color: #33ffdd;">64</span></div>
<p>Теперь нам необходимо загрузить картинку карты высот. Я использую не обычные черно белые картинки, а двухцветные: красная компонента отражает возвышения, а зеленая - углубления. Это позволяет сделать переходы более плавными. А также одна особенность: картинка имеет разрешение не кратное 2, а (кратное 2)+1 (не 256, а 257). Дабы не производить интерполяций, а сконцентрироваться на процессе создания террайна.
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_hmap.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_hmap.jpg" src="0-u3lfjw.jpg" width="257" height="257" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 10
</td></tr></table>
<p>Из загруженной картинки мы узнаем размеры создаваемой поверхности и затем будем выделять память согласно необходимости. Создадим также переменную <b>RoamTerrainMaxHeight#</b> для определния максимальной высоты в карту высот при её загрузке.
</p>
<div class="bb" style="font-family: monospace;background-color:#FFFFFF;border:1px dashed #CCCCCC;padding:10px;background-color:#225588;color:#FFFFFF;border:1px solid #003040;padding:10px;"><span style="color: #ffee00">;Устанавливаем максимальную высоту</span><br />
<p>RoamTerrainMaxHeight#=<span style="color: #33ffdd;">40.96</span><br />
<span style="color: #ffee00">;Грузим картинку</span><br />
HmapImage=<span style="color: #aaffff; font-weight: bold;">LoadImage</span><span style=" ">&#40;</span><span style="color: #00ff66;">&quot;roam_hmap.jpg&quot;</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;Достаем из картинки раземр террайна</span><br />
<span style="color: #aaffff; font-weight: bold;">Global</span> RoamTerrainWidth=<span style="color: #aaffff; font-weight: bold;">ImageWidth</span><span style=" ">&#40;</span>HmapImage<span style=" ">&#41;</span><span style="color: #33ffdd;">-1</span><br />
<span style="color: #ffee00">;создаем массив с картой высот</span><br />
<span style="color: #aaffff; font-weight: bold;">Dim</span> RoamTerrainHeight#<span style=" ">&#40;</span>RoamTerrainWidth,RoamTerrainWidth<span style=" ">&#41;</span><br />
<span style="color: #ffee00">;считываем массив из картинки</span><br />
<span style="color: #aaffff; font-weight: bold;">SetBuffer</span> <span style="color: #aaffff; font-weight: bold;">ImageBuffer</span><span style=" ">&#40;</span>HmapImage<span style=" ">&#41;</span><br />
<span style="color: #aaffff; font-weight: bold;">LockBuffer</span> <span style="color: #aaffff; font-weight: bold;">ImageBuffer</span><span style=" ">&#40;</span>HmapImage<span style=" ">&#41;</span><br />
<span style="color: #aaffff; font-weight: bold;">For</span> PixX=<span style="color: #33ffdd;">0</span> <span style="color: #aaffff; font-weight: bold;">To</span> RoamTerrainWidth<br />
<span style="color: #aaffff; font-weight: bold;">For</span> PixY=<span style="color: #33ffdd;">0</span> <span style="color: #aaffff; font-weight: bold;">To</span> RoamTerrainWidth<br />
&nbsp; &nbsp; &nbsp; &nbsp; Pixel=<span style="color: #aaffff; font-weight: bold;">ReadPixelFast</span><span style=" ">&#40;</span>PixX,PixY<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RedColor=<span style=" ">&#40;</span>Pixel <span style="color: #aaffff; font-weight: bold;">Shr</span> <span style="color: #33ffdd;">16</span><span style=" ">&#41;</span> <span style="color: #aaffff; font-weight: bold;">And</span> <span style=" ">&#40;</span>$000000FF<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; GreenColor=<span style=" ">&#40;</span>Pixel <span style="color: #aaffff; font-weight: bold;">Shr</span> <span style="color: #33ffdd;">8</span><span style=" ">&#41;</span> <span style="color: #aaffff; font-weight: bold;">And</span> <span style=" ">&#40;</span>$000000FF<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamTerrainHeight#<span style=" ">&#40;</span>PixX,PixY<span style=" ">&#41;</span>=<span style=" ">&#40;</span>RedColor/<span style="color: #33ffdd;">255.0</span><span style=" ">&#41;</span>*RoamTerrainMaxHeight-<span style=" ">&#40;</span>GreenColor/<span style="color: #33ffdd;">255.0</span><span style=" ">&#41;</span>*RoamTerrainMaxHeight<br />
<span style="color: #aaffff; font-weight: bold;">Next</span><br />
<span style="color: #aaffff; font-weight: bold;">Next</span><br />
<span style="color: #aaffff; font-weight: bold;">UnlockBuffer</span> <span style="color: #aaffff; font-weight: bold;">ImageBuffer</span><span style=" ">&#40;</span>HmapImage<span style=" ">&#41;</span><br />
<span style="color: #aaffff; font-weight: bold;">SetBuffer</span> <span style="color: #aaffff; font-weight: bold;">BackBuffer</span><span style=" ">&#40;</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;Удаляем картинку, она нам более не нужна</span><br />
</p>
<span style="color: #aaffff; font-weight: bold;">FreeImage</span> HmapImage</div>
<p>Далее определение соседей основания. Сразу же объявим перменную <b>RoamMaxTriangles</b>, показывающую, сколько всего треугольников создается при текущем разрешении террайна. Создаем массивы, содержащие базового соседа и его флаг.  Мы перечисляем все трегуольники и заносим  данные сразу в массив прямо внутри функции
</p>
<div class="bb" style="font-family: monospace;background-color:#FFFFFF;border:1px dashed #CCCCCC;padding:10px;background-color:#225588;color:#FFFFFF;border:1px solid #003040;padding:10px;"><span style="color: #ffee00">;маскимальное количество треугольников в террайне</span><br />
<p>RoamMaxTriangles=RoamTerrainWidth*RoamTerrainWidth*<span style="color: #33ffdd;">2</span><span style="color: #33ffdd;">-1</span><br />
<span style="color: #ffee00">;массивы содержащие базового соседа и его флаг</span><br />
<span style="color: #aaffff; font-weight: bold;">Dim</span> RoamBaseNeighbor%<span style=" ">&#40;</span>RoamMaxTriangles<span style=" ">&#41;</span><br />
<span style="color: #aaffff; font-weight: bold;">Dim</span> RoamBaseNeighborFlag%<span style=" ">&#40;</span>RoamMaxTriangles<span style=" ">&#41;</span><br />
<br />
<span style="color: #aaffff; font-weight: bold;">Function</span> &nbsp;FindTriBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span><br />
<span style="color: #ffee00">;если для данного треугольника уже задан сосед, то мы пропускаем</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> RoamBaseNeighbor<span style=" ">&#40;</span>number<span style=" ">&#41;</span>&gt;<span style="color: #33ffdd;">0</span>&nbsp;: <span style="color: #aaffff; font-weight: bold;">Return</span>&nbsp;: <span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<span style="color: #ffee00">;если это треугольник 1,2 или 3</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> Number&lt;<span style="color: #33ffdd;">4</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Select</span> Number<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Case</span> <span style="color: #33ffdd;">1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">1</span> <span style="color: #ffee00">;сосед в другой структуре</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Case</span> <span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span>&nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;нет соседа</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Case</span> <span style="color: #33ffdd;">3</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span>&nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;нет соседа</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">End Select</span><br />
<span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<span style="color: #ffee00">;поиск родителя и его обоих детей</span><br />
Parent=Number <span style="color: #aaffff; font-weight: bold;">Shr</span> <span style="color: #33ffdd;">1</span><br />
ParentLeftChild=<span style=" ">&#40;</span>Parent <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
ParentRightChild=<span style=" ">&#40;</span>Parent <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
<br />
<span style="color: #ffee00">;поиск прародителя и его обоих детей</span><br />
PraParent=Parent <span style="color: #aaffff; font-weight: bold;">Shr</span> <span style="color: #33ffdd;">1</span><br />
PraParentLeftChild=<span style=" ">&#40;</span>PraParent <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
PraParentRightChild=<span style=" ">&#40;</span>PraParent <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
<br />
<span style="color: #ffee00">;случай №3 в разделе &quot;Мои добавления в метод &quot; </span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> Number=ParentLeftChild <span style="color: #aaffff; font-weight: bold;">And</span> Parent=PraParentLeftChild<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;находим правого потомка правого потомка &nbsp;прародителя,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; PraParentRightChildRightChild=<span style=" ">&#40;</span>PraParentRightChild <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;который является соседом основания искомого треугольника</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=PraParentRightChildRightChild<br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;искомый треуольник является также соседом основания</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;правого потомка правого потомка прародителя</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>PraParentRightChildRightChild<span style=" ">&#41;</span>=Number<br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>PraParentRightChildRightChild<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
<span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #ffee00">;тот же случай №3 , но в обратную сторону</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> Number=ParentRightChild <span style="color: #aaffff; font-weight: bold;">And</span> Parent=PraParentRightChild<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;находим левого потомка левого потомка &nbsp;прародителя,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; PraParentLeftChildLeftChild=<span style=" ">&#40;</span>PraParentLeftChild <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;который является соседом основания искомого треугольника</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=PraParentLeftChildLeftChild<br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;искомый треуольник является также соседом основания</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;левого потомка левого потомка прародителя</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>PraParentLeftChildLeftChild<span style=" ">&#41;</span>=Number<br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>PraParentLeftChildLeftChild<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
<span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #ffee00">;Теперь проверяем есть ли у прародителя сосед основания</span><br />
<br />
PraParentBaseNeighbor=RoamBaseNeighbor<span style=" ">&#40;</span>PraParent<span style=" ">&#41;</span><br />
PraParentBaseNeighborFlag=RoamBaseNeighborFlag<span style=" ">&#40;</span>PraParent<span style=" ">&#41;</span><br />
<br />
<span style="color: #ffee00">;если нет, то и у искомого быть не может</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> PraParentBaseNeighbor=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #ffee00">;проверим случай №4</span><br />
<span style="color: #ffee00">;если искомый треугольник првый потомок, а родитель - левый</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> Number=ParentRightChild <span style="color: #aaffff; font-weight: bold;">And</span> Parent=PraParentLeftChild<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;соседом будет левый потомок правого потомка соседа основания прародителя</span><br />
&nbsp; &nbsp; PraParentBaseNeighborRightChild=<span style=" ">&#40;</span>PraParentBaseNeighbor <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
&nbsp; &nbsp; PraParentBaseNeighborRightChildLeftChild=<span style=" ">&#40;</span>PraParentBaseNeighborRightChild <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;заносим в массив и копируем флаг от флага прародителя</span><br />
&nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=PraParentBaseNeighborRightChildLeftChild<br />
&nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=PraParentBaseNeighborFlag<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">; и наоборот</span><br />
&nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>PraParentBaseNeighborRightChildLeftChild<span style=" ">&#41;</span>=Number<br />
&nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>PraParentBaseNeighborRightChildLeftChild<span style=" ">&#41;</span>=PraParentBaseNeighborFlag<br />
&nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #ffee00">;Теперь остается проверить случай №4 наоборот</span><br />
<span style="color: #ffee00">;когда искомый треугольник левый потомок, а родитель - правый</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> Number=ParentLeftChild <span style="color: #aaffff; font-weight: bold;">And</span> Parent=PraParentRightChild<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;соседом будет левый потомок правого потомка соседа основания прародителя</span><br />
&nbsp; &nbsp; PraParentBaseNeighborLeftChild=<span style=" ">&#40;</span>PraParentBaseNeighbor <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; PraParentBaseNeighborLeftChildRightChild=<span style=" ">&#40;</span>PraParentBaseNeighborLeftChild <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;заносим в массив и копируем флаг от флага прародителя</span><br />
&nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=PraParentBaseNeighborLeftChildRightChild<br />
&nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>=PraParentBaseNeighborFlag<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">; и наоборот</span><br />
&nbsp; &nbsp; RoamBaseNeighbor<span style=" ">&#40;</span>PraParentBaseNeighborLeftChildRightChild<span style=" ">&#41;</span>=Number<br />
&nbsp; &nbsp; RoamBaseNeighborFlag<span style=" ">&#40;</span>PraParentBaseNeighborLeftChildRightChild<span style=" ">&#41;</span>=PraParentBaseNeighborFlag<br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #aaffff; font-weight: bold;">End Function</span><br />
<br />
<span style="color: #ffee00">;непосредственно перебор всех треугольников и поиск их соседей оснований</span><br />
<span style="color: #aaffff; font-weight: bold;">For</span> CurrentNumber=<span style="color: #33ffdd;">1</span> <span style="color: #aaffff; font-weight: bold;">To</span> RoamMaxTriangles<br />
&nbsp; FindTriBaseNeighbor<span style=" ">&#40;</span>CurrentNumber<span style=" ">&#41;</span><br />
</p>
<span style="color: #aaffff; font-weight: bold;">Next</span></div>
<p>Далее мы можем проверить правильность функции, напчечатав в дебаг данные и проверив их хотя бы по картинке №6.
</p>
<div class="bb" style="font-family: monospace;background-color:#FFFFFF;border:1px dashed #CCCCCC;padding:10px;background-color:#225588;color:#FFFFFF;border:1px solid #003040;padding:10px;"><span style="color: #ffee00">;проверим несколько треугольников из дебага по картинке</span><br />
<p><span style="color: #aaffff; font-weight: bold;">For</span> i=<span style="color: #33ffdd;">1</span> <span style="color: #aaffff; font-weight: bold;">To</span> <span style="color: #33ffdd;">31</span><br />
<span style="color: #aaffff; font-weight: bold;">DebugLog</span> <span style="color: #00ff66;">&quot;Tri# &quot;</span>+<span style="color: #aaffff; font-weight: bold;">Str</span><span style=" ">&#40;</span>i<span style=" ">&#41;</span>+<span style="color: #00ff66;">&quot; Base neighbor: &quot;</span>+<span style="color: #aaffff; font-weight: bold;">Str</span><span style=" ">&#40;</span>RoamBaseNeighbor<span style=" ">&#40;</span>i<span style=" ">&#41;</span><span style=" ">&#41;</span> +<span style="color: #00ff66;">&quot; Flag: &quot;</span>+<span style="color: #aaffff; font-weight: bold;">Str</span><span style=" ">&#40;</span>RoamBaseNeighborFlag<span style=" ">&#40;</span>i<span style=" ">&#41;</span><span style=" ">&#41;</span><br />
</p>
<span style="color: #aaffff; font-weight: bold;">Next</span></div>
<p>Далее мы объявляем нужные нам переменные для бинарного дерева треугольников. <b>RoamCriticalLevel</b> - треугольники с номером больше этой цифры неделимые, то есть принадлежат к самому высокому уровню детализации. Банки памяти для бинарных деревьев треугольников я сохранил в элементах массива для удобства доступа к ним. Один банк для ветки 0, другой банк для ветки 1. <b>MinTileSizeLevel</b> подробнее был описан выше.
</p>
<div class="bb" style="font-family: monospace;background-color:#FFFFFF;border:1px dashed #CCCCCC;padding:10px;background-color:#225588;color:#FFFFFF;border:1px solid #003040;padding:10px;"><span style="color: #ffee00">;Все трегольники после этого числа не будут делиться</span><br />
<p><span style="color: #aaffff; font-weight: bold;">Global</span> RoamCriticalTriLevel=RoamTerrainWidth*RoamTerrainWidth<span style="color: #33ffdd;">-1</span><br />
<span style="color: #ffee00">;создаем банки памяти для хранения бинароного дерева треугольников</span><br />
<span style="color: #aaffff; font-weight: bold;">Dim</span> RoamTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
RoamTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">0</span><span style=" ">&#41;</span>=<span style="color: #aaffff; font-weight: bold;">CreateBank</span><span style=" ">&#40;</span>RoamTerrainWidth*RoamTerrainWidth*<span style="color: #33ffdd;">2</span><span style=" ">&#41;</span>&nbsp;<span style="color: #ffee00">;ветка 0 - правый верхний треугольник</span><br />
RoamTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">1</span><span style=" ">&#41;</span>=<span style="color: #aaffff; font-weight: bold;">CreateBank</span><span style=" ">&#40;</span>RoamTerrainWidth*RoamTerrainWidth*<span style="color: #33ffdd;">2</span><span style=" ">&#41;</span>&nbsp;<span style="color: #ffee00">;ветка 1 - левый нижний треугольник</span><br />
<span style="color: #ffee00">;Минимальная детализация</span><br />
</p>
<span style="color: #aaffff; font-weight: bold;">Global</span> MinTileSizeLevel=<span style="color: #33ffdd;">2</span>^<span style=" ">&#40;</span>RoamTerrainWidth/MinimumTileSize<span style=" ">&#41;</span></div>
<p>Далее идет функция, которая определяет, делить ли треугольник или нет, и функция помогающая делить соседа основания. Внутри все откомментировано. Вкратце функция сначала проверяет входит ли треугольник в число наиболее детализированных, затем входит ли треугольник в число обязательно разделяемых, затем определяется помечен ли треугольник как разбитый при ForceSplit, а потом проходит проверка погрешности высоты. <b>ForceSplit</b> сначала проверяет, разбит ли уже треугольник, затем помечает себя разбитым, разбивает соседа основания и переходит к родителю.
</p>
<div class="bb" style="font-family: monospace;background-color:#FFFFFF;border:1px dashed #CCCCCC;padding:10px;background-color:#225588;color:#FFFFFF;border:1px solid #003040;padding:10px;"><span style="color: #ffee00">; Функция, определяющая стоит ли бить треугольник или нет</span><br />
<p><span style="color: #aaffff; font-weight: bold;">Function</span> RoamBreakTriangle<span style=" ">&#40;</span>x0,z0,x1,z1,x2,z2,Number,Branch<span style=" ">&#41;</span><br />
<br />
<span style="color: #ffee00">;если треугольник входит в число наиболее детализированных</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> Number&gt;RoamCriticalTriLevel<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;помечаем как не битый и выходим</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">PokeByte</span><span style=" ">&#40;</span>RoamTriangle<span style=" ">&#40;</span>Branch<span style=" ">&#41;</span>,Number,<span style="color: #33ffdd;">0</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #ffee00">;Если треугольник входит в число треугольников наименьшей детализации</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> Number&lt;MinTileSizeLevel<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;находим координаты центральной точки</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; xC=<span style=" ">&#40;</span>x0+x2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; zC=<span style=" ">&#40;</span>z0+z2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;находим потомков</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; LeftChild=<span style=" ">&#40;</span>Number <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RightChild=<span style=" ">&#40;</span>Number <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;помечаем треугольник как разбитый</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">PokeByte</span><span style=" ">&#40;</span>RoamTriangle<span style=" ">&#40;</span>Branch<span style=" ">&#41;</span>,Number,<span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;вызываем функцию разбивания для потомков</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBreakTriangle<span style=" ">&#40;</span>x1,z1,xC,zC,x0,z0,LeftChild,Branch<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBreakTriangle<span style=" ">&#40;</span>x2,z2,xC,zC,x1,z1,RightChild,Branch<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;возврат, чтобы не делать лишних просчетов</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #ffee00">;если треугольник уже помечен как рзбитый (в процессе ForceSplit)</span><br />
<span style="color: #ffee00">;то тоже проверяем его потомков</span><br />
&nbsp;<span style="color: #aaffff; font-weight: bold;">If</span> <span style="color: #aaffff; font-weight: bold;">PeekByte</span><span style=" ">&#40;</span>RoamTriangle<span style=" ">&#40;</span>Branch<span style=" ">&#41;</span>,Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; xC=<span style=" ">&#40;</span>x0+x2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; zC=<span style=" ">&#40;</span>z0+z2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; LeftChild=<span style=" ">&#40;</span>Number <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RightChild=<span style=" ">&#40;</span>Number <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBreakTriangle<span style=" ">&#40;</span>x1,z1,xC,zC,x0,z0,LeftChild,Branch<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBreakTriangle<span style=" ">&#40;</span>x2,z2,xC,zC,x1,z1,RightChild,Branch<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #ffee00">;после предыдущих проверок остается одна возможность разбивать или</span><br />
<span style="color: #ffee00">;не разбивать треугольник - это проверка погрешности высоты</span><br />
xC=<span style=" ">&#40;</span>x0+x2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
zC=<span style=" ">&#40;</span>z0+z2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
<span style="color: #ffee00">;погрешность высоты</span><br />
DeltaHeight#=<span style="color: #aaffff; font-weight: bold;">Abs</span><span style=" ">&#40;</span>RoamTerrainHeight<span style=" ">&#40;</span>xC,zC<span style=" ">&#41;</span>-<span style=" ">&#40;</span>RoamTerrainHeight<span style=" ">&#40;</span>x0,z0<span style=" ">&#41;</span>+RoamTerrainHeight<span style=" ">&#40;</span>x2,z2<span style=" ">&#41;</span><span style=" ">&#41;</span>*<span style="color: #33ffdd;">0.5</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;если она больше максимальной ошибки то разбиваем</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> DeltaHeight&gt;=RoamMaxHeightError<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">; - &quot; -</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; xC=<span style=" ">&#40;</span>x0+x2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; zC=<span style=" ">&#40;</span>z0+z2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; LeftChild=<span style=" ">&#40;</span>Number <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RightChild=<span style=" ">&#40;</span>Number <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">PokeByte</span><span style=" ">&#40;</span>RoamTriangle<span style=" ">&#40;</span>Branch<span style=" ">&#41;</span>,Number,<span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBreakTriangle<span style=" ">&#40;</span>x1,z1,xC,zC,x0,z0,LeftChild,Branch<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamBreakTriangle<span style=" ">&#40;</span>x2,z2,xC,zC,x1,z1,RightChild,Branch<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">; если у треугольника есть сосед основания то разбиваем</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">; его специальной функцией (см ниже)</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">If</span> RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>&gt;<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;Обратите внимание что результирущая ветка находится через маску Xor</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamForceSplitTri<span style=" ">&#40;</span>RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>,Branch <span style="color: #aaffff; font-weight: bold;">Xor</span> RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<span style="color: #aaffff; font-weight: bold;">End Function</span> <br />
<span style="color: #ffee00">;функция, разбивающая соседа основания треугольника</span><br />
<span style="color: #aaffff; font-weight: bold;">Function</span> RoamForceSplitTri<span style=" ">&#40;</span>Number,Branch<span style=" ">&#41;</span><br />
<span style="color: #ffee00">;если треугольник уже разбит то выходим</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> <span style="color: #aaffff; font-weight: bold;">PeekByte</span><span style=" ">&#40;</span>RoamTriangle<span style=" ">&#40;</span>Branch<span style=" ">&#41;</span>,Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<span style="color: #ffee00">;помечаем как разбитый</span><br />
<span style="color: #aaffff; font-weight: bold;">PokeByte</span><span style=" ">&#40;</span>RoamTriangle<span style=" ">&#40;</span>Branch<span style=" ">&#41;</span>,Number,<span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;пробуем разбить его соседа основания</span><br />
<span style="color: #aaffff; font-weight: bold;">If</span> RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>&gt;<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamForceSplitTri<span style=" ">&#40;</span>RoamBaseNeighbor<span style=" ">&#40;</span>Number<span style=" ">&#41;</span>,Branch <span style="color: #aaffff; font-weight: bold;">Xor</span> RoamBaseNeighborFlag<span style=" ">&#40;</span>Number<span style=" ">&#41;</span><span style=" ">&#41;</span><br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<span style="color: #ffee00">;и переходим к родителю</span><br />
Parent=Number <span style="color: #aaffff; font-weight: bold;">Shr</span> <span style="color: #33ffdd;">1</span><br />
RoamForceSplitTri<span style=" ">&#40;</span>Parent,Branch<span style=" ">&#41;</span><br />
</p>
<span style="color: #aaffff; font-weight: bold;">End Function</span></div>
<p>Мы написали функцию, описывающую процесс разбиения треугольников. После её работы у нас имеется сформированное дерево треугольников, согласно которому мы и будем строить меш. Теперь сделаем небольшое отступление. В дереве имеется только информация о том строить ли треугольник по данным вершинам или нет, а о создании вершин в алгоритме как то не говорится. Когда мы строим треугольник, то у нас есть данные только о координатах вершин создаваемого треугольника. Создать все вершины сразу и строить по ним трианглы не получится, поэтому вершины будут строиться динамически. Создадим массив <b>RoamVertex(RoamTerrainWidth,RoamTerrainWidth)</b> в котором будем хранить информацию о том, создана ли вершина или нет. Если вершина создана то значение ячейки будет больше нуля. Т.к. первый вертекс в сюрфейсе имеет номер 0, то перед каждым обновлением будет создавать ни с чем не связаный нулевой вертекс, дабы упросить записи в архиве. Таким образом при создании треугольника проверяем значение всех вертексов треугольника в массиве, и если вершина не создана, то создаем её. После чего создаем треугольник по уже точно существующим вершинам. Таким образом, функция пробегает рекурсивно по дереву и если треугольник создан, то создавая по необходимости вершины добавляет в сюрфейс треугольник.
</p>
<div class="bb" style="font-family: monospace;background-color:#FFFFFF;border:1px dashed #CCCCCC;padding:10px;background-color:#225588;color:#FFFFFF;border:1px solid #003040;padding:10px;"><span style="color: #ffee00">;создаем меш</span><br />
<p><span style="color: #aaffff; font-weight: bold;">Global</span> RoamMesh=<span style="color: #aaffff; font-weight: bold;">CreateMesh</span><span style=" ">&#40;</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;помещаем меш в центр мира</span><br />
<span style="color: #aaffff; font-weight: bold;">PositionEntity</span> RoamMesh,<span style="color: #33ffdd;">-0.5</span>*RoamTerrainWidth,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">-0.5</span>*RoamTerrainWidth<br />
<span style="color: #ffee00">;грзим текстуру и текстурим</span><br />
tex=<span style="color: #aaffff; font-weight: bold;">LoadTexture</span><span style=" ">&#40;</span><span style="color: #00ff66;">&quot;sand.jpg&quot;</span><span style=" ">&#41;</span><br />
<span style="color: #aaffff; font-weight: bold;">ScaleTexture</span> tex,<span style="color: #33ffdd;">4</span>,<span style="color: #33ffdd;">4</span><br />
<span style="color: #aaffff; font-weight: bold;">EntityTexture</span> RoamMesh,tex<br />
<span style="color: #ffee00">;создаем сурфейс и массив вертексов</span><br />
<span style="color: #aaffff; font-weight: bold;">Global</span> RoamSurface=<span style="color: #aaffff; font-weight: bold;">CreateSurface</span><span style=" ">&#40;</span>RoamMesh<span style=" ">&#41;</span><br />
<span style="color: #aaffff; font-weight: bold;">Dim</span> RoamVertex<span style=" ">&#40;</span>RoamTerrainWidth,RoamTerrainWidth<span style=" ">&#41;</span><br />
<br />
<span style="color: #ffee00">;функция создающая треугольник па банку памяти</span><br />
<span style="color: #aaffff; font-weight: bold;">Function</span> RoamCreateTriangle<span style=" ">&#40;</span>x0,z0,x1,z1,x2,z2,Number,Branch<span style=" ">&#41;</span><br />
<span style="color: #ffee00">;если треугольник разбит, то переходм к его потомкам</span><br />
&nbsp;<span style="color: #aaffff; font-weight: bold;">If</span> <span style="color: #aaffff; font-weight: bold;">PeekByte</span><span style=" ">&#40;</span>RoamTriangle<span style=" ">&#40;</span>Branch<span style=" ">&#41;</span>,Number<span style=" ">&#41;</span>=<span style="color: #33ffdd;">1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; xC=<span style=" ">&#40;</span>x0+x2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; zC=<span style=" ">&#40;</span>z0+z2<span style=" ">&#41;</span>/<span style="color: #33ffdd;">2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; LeftChild=<span style=" ">&#40;</span>Number <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RightChild=<span style=" ">&#40;</span>Number <span style="color: #aaffff; font-weight: bold;">Shl</span> <span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><span style="color: #33ffdd;">+1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamCreateTriangle<span style=" ">&#40;</span>x1,z1,xC,zC,x0,z0,LeftChild,Branch<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; RoamCreateTriangle<span style=" ">&#40;</span>x2,z2,xC,zC,x1,z1,RightChild,Branch<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">Return</span><br />
<span style="color: #aaffff; font-weight: bold;">Else</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;или создаем тругольник</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;проверяем создан ли вертекс 0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">If</span> RoamVertex<span style=" ">&#40;</span>x0,z0<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamVertex<span style=" ">&#40;</span>x0,z0<span style=" ">&#41;</span>=<span style="color: #aaffff; font-weight: bold;">AddVertex</span><span style=" ">&#40;</span>RoamSurface,x0,RoamTerrainHeight<span style=" ">&#40;</span>x0,z0<span style=" ">&#41;</span>,z0,x0,z0<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;проверяем создан ли вертекс 1</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">If</span> RoamVertex<span style=" ">&#40;</span>x1,z1<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamVertex<span style=" ">&#40;</span>x1,z1<span style=" ">&#41;</span>=<span style="color: #aaffff; font-weight: bold;">AddVertex</span><span style=" ">&#40;</span>RoamSurface,x1,RoamTerrainHeight<span style=" ">&#40;</span>x1,z1<span style=" ">&#41;</span>,z1,x1,z1<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;проверяем создан ли вертекс 2</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">If</span> RoamVertex<span style=" ">&#40;</span>x2,z2<span style=" ">&#41;</span>=<span style="color: #33ffdd;">0</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RoamVertex<span style=" ">&#40;</span>x2,z2<span style=" ">&#41;</span>=<span style="color: #aaffff; font-weight: bold;">AddVertex</span><span style=" ">&#40;</span>RoamSurface,x2,RoamTerrainHeight<span style=" ">&#40;</span>x2,z2<span style=" ">&#41;</span>,z2,x2,z2<span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ffee00">;создаем </span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #aaffff; font-weight: bold;">AddTriangle</span> <span style=" ">&#40;</span>RoamSurface,RoamVertex<span style=" ">&#40;</span>x0,z0<span style=" ">&#41;</span>,RoamVertex<span style=" ">&#40;</span>x1,z1<span style=" ">&#41;</span>,RoamVertex<span style=" ">&#40;</span>x2,z2<span style=" ">&#41;</span><span style=" ">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <br />
<span style="color: #aaffff; font-weight: bold;">EndIf</span><br />
<br />
</p>
<span style="color: #aaffff; font-weight: bold;">End Function</span></div>
<p>А сейчас мы соберем функцию, которая собирает все выше описанное в единое целое. Сначала мы очищаем банки Бинарных Деревьев Треугольников для обеих ветвей. Потом очищаем массив вертексов и очищаем сетку меша, добавляя нулевой вертекс. Затем вызываем функции разбивания и создания треугольников для каждой из ветвей. Ну и обновляем нормали меша.
</p>
<div class="bb" style="font-family: monospace;background-color:#FFFFFF;border:1px dashed #CCCCCC;padding:10px;background-color:#225588;color:#FFFFFF;border:1px solid #003040;padding:10px;"><span style="color: #aaffff; font-weight: bold;">Function</span> CreateLand<span style=" ">&#40;</span><span style=" ">&#41;</span><br />
<p><br />
<span style="color: #ffee00">;очищаем банки памяти обеих ветвей треугольников</span><br />
<span style="color: #aaffff; font-weight: bold;">FreeBank</span> RoamTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">0</span><span style=" ">&#41;</span><br />
<span style="color: #aaffff; font-weight: bold;">FreeBank</span> RoamTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;и создаем заново пустые</span><br />
RoamTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">0</span><span style=" ">&#41;</span>=<span style="color: #aaffff; font-weight: bold;">CreateBank</span><span style=" ">&#40;</span>RoamTerrainWidth*RoamTerrainWidth*<span style="color: #33ffdd;">2</span><span style=" ">&#41;</span><br />
RoamTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">1</span><span style=" ">&#41;</span>=<span style="color: #aaffff; font-weight: bold;">CreateBank</span><span style=" ">&#40;</span>RoamTerrainWidth*RoamTerrainWidth*<span style="color: #33ffdd;">2</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;пересоздаем массив вертексов</span><br />
<span style="color: #aaffff; font-weight: bold;">Dim</span> RoamVertex<span style=" ">&#40;</span>RoamTerrainWidth,RoamTerrainWidth<span style=" ">&#41;</span><br />
<span style="color: #ffee00">;очищаем сурфейс и создаем вертекс 0</span><br />
<span style="color: #aaffff; font-weight: bold;">ClearSurface</span> RoamSurface,<span style="color: #33ffdd;">1</span>,<span style="color: #33ffdd;">1</span><br />
<span style="color: #aaffff; font-weight: bold;">AddVertex</span> RoamSurface,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">0</span><br />
<span style="color: #ffee00">;разбиваем треугольники</span><br />
RoamBreakTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">0</span>,RoamTerrainWidth,RoamTerrainWidth,RoamTerrainWidth,RoamTerrainWidth,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">1</span>,<span style="color: #33ffdd;">0</span><span style=" ">&#41;</span><br />
RoamBreakTriangle<span style=" ">&#40;</span>RoamTerrainWidth,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">0</span>,RoamTerrainWidth,<span style="color: #33ffdd;">1</span>,<span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;создаем треугольники</span><br />
RoamCreateTriangle<span style=" ">&#40;</span><span style="color: #33ffdd;">0</span>,RoamTerrainWidth,RoamTerrainWidth,RoamTerrainWidth,RoamTerrainWidth,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">1</span>,<span style="color: #33ffdd;">0</span><span style=" ">&#41;</span><br />
RoamCreateTriangle<span style=" ">&#40;</span>RoamTerrainWidth,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">0</span>,<span style="color: #33ffdd;">0</span>,RoamTerrainWidth,<span style="color: #33ffdd;">1</span>,<span style="color: #33ffdd;">1</span><span style=" ">&#41;</span><br />
<span style="color: #ffee00">;обновляем нормали</span><br />
<span style="color: #aaffff; font-weight: bold;">UpdateNormals</span><span style=" ">&#40;</span>RoamMesh<span style=" ">&#41;</span><br />
<br />
</p>
<span style="color: #aaffff; font-weight: bold;">End Function</span></div>
<p>Вот в общем то и все основные принципы алгоритма изложены. Полный работающий пример можно скачать в аттаче 
</p>
<a name=".D0.94.D0.B0.D0.BB.D1.8C.D0.BD.D0.B5.D0.B9.D1.88.D0.B8.D0.B5_.D0.BE.D0.BF.D1.82.D0.B8.D0.BC.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8"></a><h2><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=9" title="Править секцию: Дальнейшие оптимизации">править</a>]</span> <span class="mw-headline"> Дальнейшие оптимизации</span></h2>
<p>Следующим шагом в создании ландшафта будет добавление динамической детализации. В рассмотренном примере значение <b>RoamMaxHeightError</b> для всей поверхности одинаковое. Для нас необходимо сделать ландшафт наиболее детализированным вблизи камеры. Всякие попытки находить расстояние до камеры и менять значение <b>RoamMaxHeightError</b> согласно этому расстоянию к положительному результату пока не привели. Расчет для каждой координаты расстояния до камеры через квадратный корень очень и очень затратно. Используя маски, тоже не удалось собрать простого и быстрого примера. Поэтому я предлагаю немного другой вариант. Можно создать массив содержащий номер треугольника по координатам и его принадлежность к какой либо из ветвей, например <b>TriangleNumber(TerrainWidth,TerrainWidth,1)</b> (где ",0)" -номер треугольника, ",1)" - номер ветки) и затем исходя из координаты камеры находить треугольники входящие в отрезок [CamX-Dist;CamX+Dist] [CamZ-Dist;CamZ+Dist] и применять к ним функцию <i>RoamForceSplitTri</i>. Заносить в массив стоит треугольники с номером менее <i>RoamCriticalTriLevel</i>, так как это соответствует минимально необходимому уровню. Координату треугольника можно определять по <i>центральной точке</i>. Каждой ячейке массива будет принадлежать только два треугольника, являющиеся соседями оснований. Перебрав все треугольники можно заполнить весь массив. Одна и та же ячейка будет заполняться дважды, треугольником и его соседом основания, так что неважно какой именно треугольник будет в массиве, они оба будут поделены функцией <i>RoamForceSplitTri</i>. Так же есть закономерность в распределении треугольников по уровням. Нарисовав простой рисунок можно выявить эту закономерность и заставить её служить на пользу.
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_11.jpg" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:Roam_11.jpg" src="33ykz89x-2.jpg" width="600" height="150" /></a></span></div></div>
<table align="center">
<tr>
<td>Рисунок 11
</td></tr></table>
<p>Как видно каждая координата содержит только данные о двух треугольниках. Треугольники одного уровня находятся в закономерных координатах. Если продолжить рассматривать таким образом треугольники, то дойдя до самых первых треугольников обеих ветвей мы обнаружим что закономерность сохраняется, заполняются все координаты за исключением угловых точек.  Учитывая что мы можем доставать треугольники различной детализации, то можно сделать несколько уровней детализации вблизи камеры. 
</p><p>Возможная оптимизация это вынос процесса разбивания террайна из главного цикла в отдельный thread. Можно также поэкспериментировать с подменой буфера сюрфейса созданным вручную. В таком случае можно полностью вынести процесс обновления за цикл.
</p>
<a name=".D0.A1.D0.BF.D0.B8.D1.81.D0.BE.D0.BA_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D0.BE.D0.B9_.D0.BB.D0.B8.D1.82.D0.B5.D1.80.D0.B0.D1.82.D1.83.D1.80.D1.8B"></a><h2><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM&amp;action=edit&amp;section=10" title="Править секцию: Список использованной литературы">править</a>]</span> <span class="mw-headline"> Список использованной литературы </span></h2>
<p>1. Статья "Real-Time Dynamic Level of Detail Terrain Rendering with ROAM"
</p>
<dl><dd> Bryan Turner 
</dd><dd> Gamasutra
</dd><dd> URL: <a href="http://www.gamasutra.com/features/20000403/turner_01.htm" class="external free" title="http://www.gamasutra.com/features/20000403/turner_01.htm" rel="nofollow">http://www.gamasutra.com/features/20000403/turner_01.htm</a>
</dd></dl>
<p>2. Перевод этой статьи на русский с дополнениями
</p>
<dl><dd> Yatsenko Boris
</dd><dd> Mail: proton2@mail.ru
</dd><dd> URL: <a href="http://gamemaker.webservis.ru/" class="external free" title="http://gamemaker.webservis.ru/" rel="nofollow">http://gamemaker.webservis.ru/</a>
</dd></dl>
<div align="right"><a href="http://blitzetcetera.org/images/2/23/ROAM.zip" class="internal" title="ROAM.zip">скачать архив с файлами к статье</a></div>
<hr />
<p>Автор: <a href="http://blitzetcetera.org/index.php/%D0%A3%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%B8%D0%BA:MadMedic" title="Участник:MadMedic">MadMedic</a> (e-mail: MadMedic@rambler.ru, сайт: <a href="http://madmedic.by.ru/" class="external free" title="http://MadMedic.by.ru" rel="nofollow">http://MadMedic.by.ru</a>, ICQ: 240693868)
</p>
<!-- Saved in parser cache with key db1:pcache:idhash:1696-0!1!0!!ru!2 and timestamp 20071112105818 -->
<div class="printfooter">
Получено с <a href="o7-18t7b.html">http://blitzetcetera.org/index.php/%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM</a></div>
			<!-- end content -->			<div class="visualClear"></div>				</td>				<td class="rightside">				</td>			</tr>		</table>		</div>	</div>		</div>	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div></body>
<!-- Mirrored from localhost/index.php/%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B0%D0%BD%D0%B4%D1%88%D0%B0%D1%84%D1%82%D0%BE%D0%B2_%D1%81_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_ROAM by HTTrack Website Copier/3.x [XR&CO'2007], Mon, 12 Nov 2007 11:20:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
</html>