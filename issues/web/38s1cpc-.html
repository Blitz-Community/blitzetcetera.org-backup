<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru" dir="ltr">	
<!-- Mirrored from localhost/index.php/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_-_%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F) by HTTrack Website Copier/3.x [XR&CO'2007], Mon, 12 Nov 2007 11:20:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
<head>		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />				<meta name="keywords" content="Реализация клиент - серверного приложения (теория),Grover" />
		<link rel="shortcut icon" href="http://blitzetcetera.org/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="http://blitzetcetera.org/opensearch_desc.php" title="Blitz Et Cetera (Русский)" />
		<title>Реализация клиент - серверного приложения (теория) — Blitz Et Cetera</title>		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "bvih5rde.css?63"; /*]]>*/</style>		<link rel="stylesheet" type="text/css" media="print" href="gcxktlm6.css?63" />		<link rel="stylesheet" type="text/css" media="handheld" href="zumsslq_.css?63" />		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins/OfflineNew/IE50Fixes.css?63";</style><![endif]-->		<!--[if IE 5.5000]><style type="text/css">@import "/skins/OfflineNew/IE55Fixes.css?63";</style><![endif]-->		<!--[if IE 6]><style type="text/css">@import "/skins/OfflineNew/IE60Fixes.css?63";</style><![endif]-->		<!--[if IE 7]><style type="text/css">@import "/skins/OfflineNew/IE70Fixes.css?63";</style><![endif]-->		<!--[if lt IE 7]><script type="text/javascript" src="/skins/common/IEFixes.js?63"></script>		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->		<script type= "text/javascript">/*<![CDATA[*/
var skin = "OfflineNew";
var stylepath = "/skins";
var wgArticlePath = "/index.php/$1";
var wgScriptPath = "";
var wgServer = "http://blitzetcetera.org/";
var wgCanonicalNamespace = "";
var wgCanonicalSpecialPageName = false;
var wgNamespaceNumber = 0;
var wgPageName = "Реализация_клиент_-_серверного_приложения_(теория)";
var wgTitle = "Реализация клиент - серверного приложения (теория)";
var wgAction = "view";
var wgArticleId = "1705";
var wgIsArticle = true;
var wgUserName = null;
var wgUserGroups = null;
var wgUserLanguage = "ru";
var wgContentLanguage = "ru";
var wgBreakFrames = false;
var wgCurRevisionId = "3239";
/*]]>*/</script>
		<script type="text/javascript" src="2nq-6cel.js?63"><!-- wikibits js --></script>		<script type="text/javascript" src="http://blitzetcetera.org/index.php?title=-&amp;action=raw&amp;gen=js"><!-- site js --></script>		<style type="text/css">/*<![CDATA[*/
@import "http://blitzetcetera.org/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
@import "http://blitzetcetera.org/index.php?title=MediaWiki:OfflineNew.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
@import "http://blitzetcetera.org/index.php?title=-&amp;action=raw&amp;gen=css&amp;maxage=18000";
/*]]>*/</style>		<!-- Head Scripts -->	</head><body  class="mediawiki ns-0 ltr page-Реализация_клиент_-_серверного_приложения_теория">	<div id="globalWrapper">	<div id="logocontainer">		<table align="center">		  <tr>				<td id="blitzetclogo">				</td>			</tr>		</table>	</div>	<div id="magbar">	Журнал о программированнии на языках Blitz3D, BlitzMax, BlitzPlus	</div>		<div id="column-content">	<div id="content">		<a name="top" id="top"></a>				<div id="bodyContent">		<table cellspacing=0 cellpadding=0 width=100%>			<tr>			  <td class="leftside">				</td>				<td class="sheetbody">					<h1 class="sheet">Реализация клиент - серверного приложения (теория)</h1>			<h3 id="siteSub">Материал из Blitz Et Cetera.</h3>			<div id="contentSub"></div>			<!-- start content -->			<p>Определимся с проблемой: Многие пытались написать сетевую игру – один сервер и много клиентов. На этапе разработки сервер и клиент запускаются на одном компьютере (для быстрой работы) и все хорошо работает, но как только начинается тестирование с удаленных ПК, то весь проект захлебывается в трафике и не успевает обрабатывать данные! 
Я попытаюсь рассмотреть основные аспекты проектирования и создания сетевых игр.
</p><p>Структура проекта напрямую зависит от выбора вида соединения. Blitz предлагает нам три стандартных варианта&nbsp;: DirectPlay, UDP, TCP/IP.
</p><p>DirectPlay – давным-давно очень умные и великие программисты придумали и создали DirectX. DirectX - это набор драйверов, программ и библиотек, призванные облегчить жизнь всем программистам. DirectPlay – это часть из пакета DirectX, отвечающая за сеть, т.е. легко и просто создается сервер и клиенты. Нам, как программистам, не надо знать, как устроены и даже как называются методы реализации соединения нескольких ПК. Это уже готовый сетевой движок, пишем пару строк в коде и все. Движок этот продуман и достаточно быстр. Стоило бы остановиться именно на этом, если б не огромный недостаток движка – DirectPlay открывает множество портов в большом диапазоне, создаются подключения не только к серверу, но и между самими клиентами. Все бы хорошо (какая нам разница), но если на клиентских машинах стоят защитники (антивирусы и фаерволы), то пользователю их придется настраивать, а это плохо – ибо мало пользователей могут настроить защиту ПК для работы движка DirectPlay. Если все игроки вашего проекта сетевые Гуру или Вы напишите подробную инструкцию по настройке, то смело, выбираем этот движок и пропускаем пару страниц этой статьи.
</p><p>UPD – это не движок, это «дырка». Посылать данные через протокол UDP, все равно, что выбрасывать данные в окно с 10-го этажа и при этом кричать в окно имя адресата, получит ли адресат данные или нет, никто не знает. Но не надо думать плохо об этом протоколе – он хороший, самый быстрый способ передачи данных. Самая распространенная ошибка - это реализация проверки получения данных, т.е. сервер проверяет, получил ли клиент его данные. Если вдруг вам обязательно необходимо убедиться, что данные дошли до адресата и без потерь, то этот протокол не для вас. UDP обычно используют в экшенах от первого лица, тут нужна быстрая передача огромного потока данных и факт получения не обязателен, т.к. ситуация в игре уже изменилась. 
</p><p>TCP\IP - в отличии от UDP этот протокол доставляет данные в любом случае (кроме потери связи с клиентом) и гарантирует что полученные данные совпадают отправленным, т.е. нет потерь. Но этот протокол самый медлительный, т.к. требуется перепроверка данных. 
</p><p>Выбор способа лежит полностью на ваших плечах! Я много экспериментировал с этими инструментами реализации сетевых приложений и убедился, что лучший способ это совместное использование протоколов TCP/IP и UDP. Что и реализовано в DirectPlay, но так как мы не сможем контролировать порты и потоки при использовании DirectPlay, то от него мы отказываемся. Точнее, я отказываюсь, Вы же можете использовать его и радоваться.
</p><p>И так, «совместное использование» - это создание нескольких соединений от одного клиент к серверу, т.е. одна программа создает несколько потоков. К примеру, по надежному (TCP) потоку проходят Имя и Пароль пользователя, а по быстрому (UDP) его координаты и действия.
</p><p>Чем больше параллельных потоков используется, тем быстрей работает проект, главное, что бы сервер справился. Конечно, это не означает, что можно создавать и менять потоки как перчатки – все хорошо в меру.
</p>
<a name=".D0.A1.D1.82.D1.80.D1.83.D0.BA.D1.82.D1.83.D1.80.D0.B0_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D0.BE.D0.B2"></a><h2><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_-_%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_%28%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F%29&amp;action=edit&amp;section=1" title="Править секцию: Структура проектов">править</a>]</span> <span class="mw-headline">Структура проектов</span></h2>
<p>Синхронизация – это великое слово надо всегда писать с большой буквы, ибо от него зависит корректная работа проекта. К примеру, есть сервер и два подключенных к нему клиента, один клиент на супер-дупер компьютере играется, а второй на раритетном варианте 1986 года. И что мы получим не используя Синхронизацию? Примерно следующее: супер-дупер ПК уже прибежал к финишу, а наш раритет толь услышал команду на старт. Эта же ситуация произойдет и при различной скорости соединения, один на ADSL и второй на Dial-up. И тут мы должны синхронизировать наши клиентские программы. Т.е. в секунду планетарного времени клиент выполняет строго определенное количество операций. (например, в секунду 10 раз проверить позицию игрока). Таким образом, все клиенты на различных ПК и с различной скоростью подключения будут работать с одной скоростью. Только стоит установить минимальные требования к ПК и скорости подключения. Супер-компьютер замедлится до скорости вашей программы, а вот раритет не разгонишь.
</p><p>В Синхронизации есть свои нюансы: сбор данных из сети должен производиться всегда! И без задержек. Т.е. чем быстрее и чаще считываются данные, тем лучше. Обработку полученных данных тоже производим почаще и побыстрее, а вот количество обновлений игрового мира необходимо строго ограничить. В зависимости от самого проекта, количество обновлений в секунду выбирается авторами проекта. Для моей сетевой РПГ с максимумом в 30 пользователей одновременно, я выставлял 35 обновлений мира в секунду. При этом с игрой справлялся даже ПК с процессором на 800 МГц – но все зависит от игрового мира, эффектов - в общем - от самого проекта. 
</p><p>Возникает вопрос: Если получаем данные 100 раз в секунду, а обрабатываем только 30 раз, то мы теряем данные? А вот и нет: надо создавать очередь действий. Все новые присланные команды становятся в очередь последними и ждут обработки. Если команда супер срочная (такая как бан игрока на год), то она ставится первой. Это реализуется введением приоритета команд. Например, у каждой команды создается переменная и чем выше значение этой переменной, тем ближе к началу очереди ставится команда.
</p><p>«Сервер – это не список юзеров, это вся игра&nbsp;!!!» (С) Я.&nbsp;: ) 
Именно так и никак иначе. В идеале, сервер просчитывает положение пользователей, знает у кого сколько ресурсов и где все хранится, именно он рассчитывает повреждения и урон. Сервер делает всю работу, а задача клиента лишь отображать работу сервера и сообщать о желаниях пользователя. Именно о желаниях – пользователь не идет вперед, он только сообщает серверу, что хочет сделать шаг вперед, а сервер решает можно туда шагать или нет. Таким образом сервер в курсе всего происходящего, потому что он и создает это «происходящее». Этот процесс существует для того, что бы на всех клиент-приложениях ситуация в мире была одинаковая. Клиенту остается только нарисовать на экране, что требуется, и раскрасить картинку эффектами. К примеру, происходит взрыв, сервер просчитывает все последствия взрыва (повреждения игрокам) и сообщает всем клиентам о взрыве (его координаты), и новую ситуацию в мире, а клиенты рисуют красивый взрыв, просчитывают как разлетаются частицы земли т.д.
Опять же пользователь не подбирает предмет с земли, а спрашивает разрешения у сервера.
</p><p>Помимо того, что ситуация в мире у всех клиентов одинаковая, мы получаем еще и отсутствие огромного количества багов. Например, клиент подобрал меч, а на сервере его уже подобрал другой игрок (ну не успел обновиться клиент), вот вам и баг – дубляж предмета. А если б клиент спросил у сервера «можно ли подобрать вооон-тот клевый мечик???», то сервер бы ответил «там нет меча, тебя глючит – обновись!!!».
</p>
<a name=".D0.9F.D0.B5.D1.80.D0.B5.D1.81.D1.8B.D0.BB.D0.BA.D0.B0_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"></a><h2><span class="editsection">[<a href="http://blitzetcetera.org/index.php?title=%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_-_%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_%28%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F%29&amp;action=edit&amp;section=2" title="Править секцию: Пересылка данных">править</a>]</span> <span class="mw-headline">Пересылка данных</span></h2>
<p>Во всех уроках, статьях и книгах рекомендуют собирать все передаваемые данные в одну строку и отправлять их. Все они правы наполовину:
</p>
<ol><li>Если отправлять 100 координат (все юзеры в мире) по одной, то это займет намного больше времени, чем отправка этих же координат собранных в одну строку и разделенных в ней специальным знаком. – тут они совершенно правы, разница получается огромной.
</li><li>Процесс формирования строки для отправки и процесс разбора это строки обратно занимает уйму времени! Операции со строками самые медленные в любом языке программирования, и причем, медленнее остальных раза в 3, а то и в 4.
</li></ol>
<p>ААА….. Что же делать? Использовать стеки, последовательности, банки, пакеты – как хотите, так и называйте – это все понятия одного и того же метода работы с данными. Мне ближе к душе понятие «Банк». Смысл такой, в оперативной памяти выделяется кусок определенного размера и записываются в него байтики (не бантики, а БАЙТики). Объясняю: Переменная любого типа хранится в байтиках. Наверняка в книгах встречали таблички с типами данных и их размерами. Что бы компьютер хранил данные в памяти или на диске, эту переменную переводят в байтики. К примеру, переменную типа Float – дробные числа – хранят в 4-х байтиках. Проще – на любой знак (буква, цифра и спецсимволы) требуется ОДИН байт. Слово «МИР» имеет размер 3 байтика. 
</p><p>Для передачи данных мы формируем не строку, а банк.
</p><p>Пример:
Для передачи позиции пользователя в мире. Надо передать имя юзера и его координаты: 
</p>
<ul><li> Имя – это строка, количество байт = количеству знаков – Вася – 4 байта
</li><li> X – координата Х, это дробная переменная = 4 байта
</li><li> Y – координата Y, это дробная переменная = 4 байта
</li><li> Z – координата Z, это дробная переменная = 4 байта
</li></ul>
<p>Итого: 16 байт, а в строке это выглядело бы так&nbsp;: «%Вася%10.4%234.3%234,43%» - 24 байта.
НО! Сформировать, получить и обработать банк намного проще и быстрее.
</p><p>Как сформировать и передать банк? – зависит от языка программирования. Во всех, что я видел, эти функции реализованы и работают очень быстро.
</p><p>Когда я начал использовать банки, то сразу реализовал это так: все команды для отправки формируются в банки одного размера, перед отправкой все созданные банки объединяются в один и отправляются «кучей». Клиент получает «кучу», и зная размер одного (все одинаковые) банка, разбивает «кучу» на много маленьких банков.
Один банк выглядел примерно так:
</p>
<ol><li> Команда (20 байт)
</li><li> X,Y,Z (4*3=12 байт)
</li><li> DP1, DP2 (2*2=4) – дополнительные переменные (например кол-во денег)
</li><li> Текст (200 байт)
</li></ol>
<p>Итого банк был размером в 236 байт.
Принцип работы рассмотрим на примере:
</p>
<ol><li> Подключился новый юзер.
</li><li> формируем банк с его координатами
</li><li> формируем банк с его деньгами
</li><li> формируем банк с его вещами
</li><li> формируем банк с сообщением о подключении.
</li><li> объединяем все 4 банка в «кучу» = 944байт
</li><li> отправляем юзеру кучу.
</li></ol>
<p>И тут сразу бросается в глаза размер «кучи»  - почти килобайт!!! И действительно моя программа работала быстро, но кушала огромное количество трафика. Решение приходит на ум само собой – для каждой команды свой банк с определенным размером, но как клиент, получив кучу, узнает на какие банки ее разбить? Для этого банк подразделяется на две составляющие – Шапка и Тело. 
</p>
<ul><li> Шапка – это заголовок любого банка. Шапка имеет один  не прикосновенный размер. Шапка служит для указания клиенту и серверу информации об отправителе и данных в Теле
</li><li> Тело – последовательность данных.
</li></ul>
<p>К примеру, Шапка:
</p>
<ol><li> Размер всего банка (2 байта)
</li><li> Имя отправителя (20 байт)
</li><li> Номер команды (2 байта)
</li></ol>
<p>Клиент получая «кучу», считывает первые 2 байта и узнает размер первого банка (создали, сохранили и поставили в очередь), Размер первого банка = началу второго банка… размеры первого и второго банков в сумме дают начало третьего… т.д. и т.п. 
Таким образом, клиент правильно разобьет «кучу» на банки. Начало тела каждого банка есть размер шапки банка, а он неизменен.
</p><p>Еще одно преимущество банков, точнее не преимущество, а рекомендации к использованию: на этапе обработки входящих данных, действий юзеров и ситуации в мире «куча» увеличивается в размере (добавляются новые команды) и только в конце основного цикла или синхронизировано N-ое количество раз в секунду отправляется на сервер или клиенту. Это важно, так как отправляя «кучу» слишком часто, мы теряем в скорости работы проекта, но и наоборот – отправляя слишком редко, мы тормозим процесс обновления мир у клиентов. Поэтому следует внимательно и точно просчитать момент отправки «кучи». Для начала можно отправлять «кучу» сразу после обработки всех входящих команд и сбора новых от юзера и игрового мира. И как только возникнут проблемы, сразу рассчитать момент отправки.
</p><p>Я рекомендую следующую структуру сервера и клиента:
</p>
<div class="center"><div class="floatnone"><span><a href="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:SrvClient01.png" class="image" title=""><img alt="" longdesc="http://blitzetcetera.org/index.php/%D0%98%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:SrvClient01.png" src="ajsncaag.png" width="145" height="412" /></a></span></div></div>
<p>(*** - блок, который обязательно необходимо синхронизировать)
</p><p>ИТОГО: Начиная писать свою первую сетевую игру, я долго и упорно искал статьи и уроки в тему реализации сетевых приложений. Всё.
</p>
<hr />
<p>Автор: <a href="http://blitzetcetera.org/index.php/%D0%A3%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%B8%D0%BA:Grover" title="Участник:Grover">Grover</a> (e-mail: mail_grover@mail.ru)
</p>
<!-- Saved in parser cache with key db1:pcache:idhash:1705-0!1!0!!ru!2 and timestamp 20071112105851 -->
<div class="printfooter">
Получено с <a href="38s1cpc-.html">http://blitzetcetera.org/index.php/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_-_%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_%28%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F%29</a></div>
			<!-- end content -->			<div class="visualClear"></div>				</td>				<td class="rightside">				</td>			</tr>		</table>		</div>	</div>		</div>	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div></body>
<!-- Mirrored from localhost/index.php/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_-_%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F) by HTTrack Website Copier/3.x [XR&CO'2007], Mon, 12 Nov 2007 11:20:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
</html>