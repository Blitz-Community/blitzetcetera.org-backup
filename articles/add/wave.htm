<html><head><title>Wave’s~ BlitzMax Tutorial ~ 2004 - 7 Jan ~ Version 5</title><style>
@font-face {font-family: Impact}
@font-face {font-family: Century Gothic}
@font-face {font-family: Wingdings-Regular}
P, LI, DIV {FONT-FAMILY: "Times New Roman"; FONT-SIZE: 12pt; MARGIN: 0cm 0cm 0pt; mso-style-parent: ""}
table {font-size:10.0pt;font-family:"Times New Roman";}
#t1 {background-color:#CCCCCC;tab-interval:35.4pt}
#t3 {color:#818181;font-family:arial;font-size:8pt}
#t4 {align:center}
#t5 {color:black;font-family:impact;font-size:15.5pt}
#t7 {align:center;width:640}
#t8 {color:black;font-family:century gothic;font-size:15.5pt}
#t9 {color:black;font-family:century gothic;font-size:6pt}
#t11 {color:black;font-family:arial;font-size:8pt}
#t12 {color:black;font-family:arial;font-size:8pt}
#t13 {color:black;font-family:arial;font-size:9pt}
#t22 {color:black;font-family:century gothic;font-size:11.5pt}
#t23 {color:black;font-family:arial;font-size:9.5pt}
#t24 {color:#008100;font-family:arial;font-size:9.5pt}
#t25 {color:#000000}
#t27 {color:#008100}
#t30 {color:green}
#t31 {color:#008000}
#t32 {color:black;font-family:arial;font-size:6.5pt}
#t33 {font-family:arial;size:2}
#t34 {font-family:arial}
#t35 {color:black;font-family:arial;font-size:9.5pt}
#t36 {color:black;font-family:century gothic;font-size:11.5pt}
#t37 {color:#008100;font-family:arial;font-size:9.5pt}
#t38 {color:#008100;font-family:arial;font-size:9.5pt}
#t39 {color:black;font-family:impact;font-size:15.5pt}
#t40 {color:black;font-family:arial;font-size:9pt}
#t41 {font-family:"times new roman";font-size:3}
#t45 {color:black}
#t46 {color:#818181;font-family:arial;font-size:8pt}
#t47 {color:#008100;font-family:arial}
#t48 {color:black;font-family:arial;font-size:9pt;left:10px;top:9740px}
#t49 {color:black;font-family:arial;font-size:9.5pt;left:10px;top:9803px}
#t50 {font-size:1}
#t51 {color:#0000ff}
#t52 {color:blue;font-family:arial;font-size:9.5pt}
</style>
</head><body id=t1><p><b><span id=t3>Учебник, написанный&nbsp;Wave~ по BlitzMax&nbsp;~ 2004 - 7&nbsp;Январь ~&nbsp;Версия 5</span></b></p><p id=t4><span id=t5><a name=p1><span id=t5>1</span></a></span></p><p id=t6><span id=t5></span>&nbsp; </p><table id=t7> <tbody> <tr> <td> <p><b><span id=t8>Руководство по BlitzMax для начинающих&nbsp;&nbsp; </span></b><b><span id=t9>версия 5</span></b></p> <p><b><span id=t9></span></b>&nbsp; </p> <ul> <li> <div><b><span id=t11>&nbsp;<a href="#b1">Обзор</a></span></b><b><span id=t12>................................................................................................................................................................... <a href="#p1">1</a></span></b></div> <li> <div><b><span id=t12><a href="#b2">Переменные</a>&nbsp;....................................................................................................................................................... <a href="#p2">2</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b3">Global&nbsp;или Local</a> ................................................................................................................................................. <a href="#p2">2</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b4">Константы</a> &nbsp;..........................................................................................................................................................&nbsp;<a href="#p2"> 2</a></span></b></div> <li> <div><b><span id=t12><a href="#b5">Комментарии</a>........................................................................................................................................................ <a href="#p2">2</a></span></b></div> <li> <div><b><span id=t12><a href="#b6">If-структуры</a> .......................................................................................................................................................... <a href="#p3">3</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b7">Then</a> ..................................................................................................................................................................... <a href="#p3">3</a></span></b></div> <li> <div><b><span id=t12><a href="#b8">Not True&nbsp;или &lt;&gt; False?</a> .......................................................................................................................................&nbsp;<a href="#p3"> 3</a></span></b></div> <li> <div><b><span id=t12><a href="#b9">Графика: начало</a> &nbsp;.................................................................................................................................................. <a href="#p3">3</a></span></b></div> <li> <div><b><span id=t12><a href="#b10">Циклы</a>..................................................................................................................................................................... <a href="#p4">4</a></span></b></div> <li> <div><b><span id=t12><a href="#b11">Flip&nbsp;и Clear</a> ............................................................................................................................................................. <a href="#p4">4</a></span></b></div> <li> <div><b><span id=t12><a href="#b12">Координатная система</a> ....................................................................................................................................... <a href="#p4">4</a></span></b></div> <li> <div><b><span id=t12><a href="#b13">Ввод</a>........................................................................................................................................................................ <a href="#p5">5</a></span></b></div> <li> <div><b><span id=t12><a href="#b14">Функции</a>&nbsp;................................................................................................................................................................ <a href="#p5">5</a></span></b></div> <li> <div><b><span id=t12><a href="#b15">Random</a>.................................................................................................................................................................. <a href="#p6">6</a></span></b></div> <li> <div><b><span id=t12><a href="#b16">Массивы</a> &nbsp;................................................................................................................................................................ <a href="#p6">6</a></span></b></div> <li> <div><b><span id=t12><a href="#b17">Типы</a> &nbsp;....................................................................................................................................................................... <a href="#p7">7</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b18">Установка и создание типов(объектов)</a> ....................................................................................................... <a href="#p7">7</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b19">Списки типов</a> &nbsp;...................................................................................................................................................... <a href="#p8">8</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b20">Методы</a> &nbsp;................................................................................................................................................................. <a href="#p9">9</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b21">Функции в типах</a> &nbsp;................................................................................................................................................ <a href="#p10">10</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b22">Пара функций и методов&nbsp;TList-а</a> .................................................................................................................... <a href="#p12">12</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b23">Массивы в типах</a> ................................................................................................................................................. <a href="#p12">12</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b24">Расширение типов</a> ............................................................................................................................................. <a href="#p13">13</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b25">Замещение(Override)&nbsp;методов</a> ...................................................................................................................... <a href="#p16">16</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b26">Self</a> ......................................................................................................................................................................... <a href="#p16">16</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b27">Super</a>...................................................................................................................................................................... <a href="#p18">18</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b28">Кастинг</a>................................................................................................................................................................... <a href="#p18">18</a></span></b></div> <li> <div><b><span id=t12>&nbsp;<a href="#b29">Abstract&nbsp;и Final</a> ..................................................................................................................................................... <a href="#p18">18</a></span></b></div> <li> <div><b><span id=t12><a href="#b30">Частота обновления и&nbsp;Delta Time</a> ..................................................................................................................... <a href="#p19">19</a></span></b></div> <li> <div><b><span id=t12><a href="#b31">Картинки</a> &nbsp;................................................................................................................................................................. <a href="#p21">21</a></span></b></div> <li> <div><b><span id=t12><a href="#b32">Таймеры в реальном времени</a> &nbsp;......................................................................................................................... <a href="#p22">22</a></span></b></div> <li> <div><b><span id=t12><a href="#b33">Анимация</a>................................................................................................................................................................. <a href="#p22">22</a></span></b></div> <li> <div><b><span id=t12><a href="#b34">Сохраняем картинки в&nbsp;.exe</a> ................................................................................................................................. <a href="#p22">22</a></span></b></div> <li> <div><b><span id=t12><a href="#b35">Звуки</a>&nbsp;........................................................................................................................................................................ <a href="#p22">22</a></span></b></div> <li> <div><b><span id=t12><a href="#b36">Коротко о тесте на столкновения</a> &nbsp;..................................................................................................................... <a href="#p23">23</a></span></b></div> <li> <div><b><span id=t12><a href="#b37">Создай свою первую игру на&nbsp;BlitzMax</a> ............................................................................................................... <a href="#p23">23</a></span></b></div> <li> <div><b><span id=t12><a href="#b38">Улучшение этого руководства</a> &nbsp;............................................................................................................................ <a href="#p24">24</a> </span></b></div> <li> <div><b><span id=t12><span id=t12><a href="#b39">Кто перевел</a> &nbsp;............................................................................................................................................................ <a href="#p24">24</a></span> </span></b></div></li></ul> <p><b><span id=t13></span></b>&nbsp;</p> <p><b><span id=t13><a name=b1><b><span id=t13>Обзор</span></b></a></span></b> </p> <p><b><span id=t13></span></b>&nbsp; </p> <p><span id=t13>&nbsp; Я написал это руководство для новичков в <strong>BlitzMax</strong> или даже новичков в программировании, особенно</span> </p> <p><span id=t13>рекоммендую его для тех, кто делает первые шаги в ООП blitz-а. Это руководство не написанно в виде</span> </p> <p><span id=t13><strong>Blitz3D</strong> &gt; <strong>BlitzMax</strong>. Моей целью было дать <em>всем</em> возможность изучить <strong>BlitzMax</strong>. Если ты переходишь с <strong>Blitz3D</strong> на <strong>BlitzMax</strong>, то у тебя будет шок,&nbsp;так как тут&nbsp;появилось&nbsp;очень много нового.&nbsp;Методы достижения задач&nbsp;поменялись но, поверь мне, это только к лучшему.&nbsp;После&nbsp;того, как ты хоть маломальски разберешься с <strong>BlitzMax</strong>&nbsp;ты не найдешь места лучше <strong>BlitzMax</strong> ;)</span> </p> <p></p> <p><b><span id=t3></span></b></p> <p><b><span id=t3></span></b>&nbsp; </p> <p id=t4><span id=t5><a name=p2><span id=t5>2</span></a></span></p> <p id=t4><span id=t5></span>&nbsp;</p> <p><b><i><span id=t22><a name=b2><b><i><span id=t22>Переменные</span></i></b></a></span></i></b></p> <p><b><i><span id=t22></span></i></b>&nbsp;</p> <p><span id=t23>&nbsp; Переменная - это место, где хранится число или текст. Есть различные "типы" переменных, в зависимости от цели их использования. Вот&nbsp;наиболее часто&nbsp;используемые:</span></p> <p><span id=t23>Целые(<strong><em>Integers</em></strong>) хранят числа, Строки(<strong><em>Strings</em></strong>) хранят текст, Дробные(<strong><em>Float</em></strong>) хранят десятичные дроби.</span></p> <p><span id=t23>Так-же есть объекты(<strong><em>objects</em></strong>), которые включают в себя всё от <em>массивов(<strong>Array</strong>) </em>и<em>&nbsp;списков(<strong>List</strong>) </em>до определенных тобой типов. Это довольно широкая тема, так-чо смотри <strong>Language Reference</strong>(Описание языка) для получения деталей. Если ты хочешь увеличить переменную, скажем скорость(<em>speed</em>). Ты можешь написать: <strong>Speed = Speed + Acceleration</strong> или короче: <strong>Speed:+ Acceleration</strong>. Обе эти записи делают одно и тоже. Рекоммендуется, но <em>не </em>требуется декларирование(задание) переменных перед их использованием:</span></p> <p><span id=t23></span>&nbsp;</p> <p><span id=t24>Speed:Float=0, Acceleration:Int , Name:String= "Name"</span></p> <p><span id=t24>Speed#=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, Acceleration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Name$ = "Name"</span></p> <p><span id=t24></span>&nbsp;</p> <p><span id=t24><span id=t23>Эти две строки идентичны, используй любой способ, какой тебе больше понравится.</span></span></p> <p><span id=t24><span id=t23><strong><em>Замечание:</em></strong> если ты привык к C, C++, Java, то тебе не захочется, чтобы <strong>BlitzMax</strong> сам&nbsp;автоматически декларировал переменные при их первом использовании. Если ты хочешь, чтобы все переменные декларировались тобой(как выше), то используй комманду <strong><em>Strict</em></strong>, которая выдаст тебе ошибку компиляции, если есть переменная, которую ты не декларировал каким-нибудь способом, как, например, этими:</span></span></p> <p><span id=t24><span id=t23><span id=t23><strong>Local/Global VarName:VarType , 2ndVarName:VarType</strong></span></span></span></p> <p><span id=t24><span id=t23><span id=t23>Я не использую <strong><em>Strict </em></strong>в моих примерах, так что, если ты хочешь её ипользовать, то убедись, что ты задекларировал все мои переменные. Я бы рекоммендовал тебе использовать <strong><em>Strict</em></strong>, если ты ленивый; это поможет найти&nbsp;синтаксические ошибки перед тем, как они проявятся.</span></span></span></p> <p><span id=t24><span id=t24><span id=t23><strong><em>Замечание:</em></strong> <strong>BlitzMax</strong> считает <em>Speed</em> и <em>speed</em> и <em>sPeEd</em> как ОДНА И ТАЖЕ переменная. Тоже самое и со всеми коммандами. Как <em><strong>rem</strong> </em>или <em><strong>Rem</strong></em> или <em><strong>reM</strong></em>.</span></span></span></p> <p><span id=t24><span id=t24><span id=t23></span></span></span>&nbsp;</p> <p><span id=t24><span id=t24><span id=t23><span id=t13><strong><a name=b3><span id=t24><span id=t24><span id=t23><span id=t13><strong>Global&nbsp;или Local</strong></span></span></span></span></a> </strong></span></span></span></span></p> <p><span id=t24><span id=t24><span id=t23><span id=t13><strong>&nbsp;&nbsp; </strong>Переменная может быть <strong>Global</strong>(глобальной) или <strong>Local</strong>(локальной). <strong>Global</strong>s доступны из любого места всей программы. С <strong>Local</strong>s дело обстоит сложнее, это вызванно тем, что их существование зависит от того, где они были декларированны. Чтобы задать локальную переменную нужно писать слово <strong>Local</strong> перед именем переменной. Если ты задаешь локальную переменную <em>в функции</em>, то она будет существовать <u>только</u> в функции. Если ты декларировал переменную в цикле, то она будет существовать пока ты в этом цикле. Если локальная переменная декларируется в <strong>If</strong>-структуре, то она будет существовать только в этой <strong>If</strong>-структуре.</span></span></span></span></p> <p><span id=t24><span id=t24><span id=t23></span></span></span>&nbsp;</p> <p><span id=t24><span id=t24><span id=t23><span id=t13><strong><a name=b4><span id=t24><span id=t24><span id=t23><span id=t13><strong>Константы</strong></span></span></span></span></a></strong></span></span></span></span></p> <p><span id=t24>&nbsp; <font id=t25>Также можно декларировать константы. Константа будет хранить только то значение, которое ты дал ей во время её декларирования. Константы - это НЕ переменные, так как их значение нельзя изменить. Это может быть полезным, так, например, ты не сможешь по ошибке изменить важное значение(Как mapWidth). Если ты попытаешься изменить значение константы, то компилятор скажет тебе об этом при компиляции.</font></span></p> <p> <p><span id=t23></span>&nbsp;</p> <p id=t26></p> <p><span id=t23><span id=t22><strong><em><a name=b5><span id=t23><span id=t22><strong><em>Комментарии</em></strong></span></span></a></em></strong></span></span></p> <p>&nbsp;</p> <p><span id=t23>Комментарии(<em>Comments</em>) - это текст, который объясняет код. Комментарии не нужны для работы твоих программ, но являются одной из тех вещей, без которых нельзя жить. Пот пример комментария:</span></p> <p><span id=t23><span id=t24>Speed#=0 'Ставим скорость равной нулю</span><span id=t23>. Символ <font id=t27>'</font>&nbsp;показывает,&nbsp;что всё, что после него на этой строке - это комментарий. Также можно использовать</span></span></p><span id=t23><span id=t23> <p><span id=t24>Rem</span></p> <p><span id=t24>если ты хочешь закомментировать несколько строк</span></p> <p><span id=t24>End Rem</span></p> <div></span></span><span id=t23>Комментарии помогут(<em>очень</em>) другим людям, когда будут читать твой код и тебе, потомучто ты в конечном счете забудешь, зачем ты сделал так или зачем&nbsp;добавил эту функцию. Пока ты начинаешь с программированием, я бы посоветовал&nbsp;тебе комментировать каждую строку.</span> </div> <p><span id=t23></span>&nbsp;</p><span id=t23> <p id=t4><span id=t5><a name=p3><span id=t5>3</span></a></span></p> <p><b><i><span id=t22><a name=b6><b><i><span id=t22>If-структуры</span></i></b></a></span></i></b></p></span> <p><span id=t23>&nbsp; <font><strong>If</strong>-структуры используются, если тебе нужно при определенных условиях выполнить определенное действие. Следующий пример не делает ничего особенного, он просто показывает тебе, как использовать <strong><em>If</em></strong>, <strong><em>Else</em></strong> <strong><em>If</em></strong>, <strong><em>Else</em></strong>&nbsp;и <strong><em>EndIf</em></strong>.</font> (<em>A</em>,<em>B</em>,<em>C</em>&nbsp;и<span id=t23> <em>R</em>&nbsp;- переменные)</span></span></p> <p><span id=t23><font><span id=t23></span></font></span>&nbsp;</p><span id=t23><font><span id=t23> <p><span id=t24>If A &gt; 10 ' Читай:&nbsp;Если A&nbsp;больше чем&nbsp;10..</span></p> <p><span id=t24>A = 10 ' Читай:&nbsp;Сделать A&nbsp;равным 10</span></p> <p><span id=t24>Else If A &lt; 0 And B = &gt; 2 ' Читай:&nbsp;если A&nbsp;меньше чем&nbsp;0&nbsp;и B&nbsp;больше или равно&nbsp;2...</span></p> <p><span id=t24>R:- 10 'Читай:&nbsp;Уменьшить R&nbsp;на 10. Т.е.&nbsp;если R&nbsp;было равным&nbsp;100, то станет&nbsp;90</span></p> <p><span id=t24>Else 'Читай:&nbsp;если не одно из условий не встречается, то делать это..</span></p> <p><span id=t24>A:+B 'Читай:&nbsp;Прибавить B&nbsp;к A.&nbsp;Или увеличить&nbsp;A&nbsp;на B.&nbsp;Это тоже самое, что: B = B + A</span></p> <p><span id=t24>End If</span></p> <p><span id=t24></span>&nbsp;</p></span></font></span> <p><span id=t23>Также можно писать <strong>if</strong>-структуру в одну строку. Символ <font id=t27>;</font> означает новое выражение(Читай: переход на следующую строку)</span></p> <div><span id=t24>If A &lt; 0 And C=2 Then B = 2 ; C=3; R:+5 else A=1; C:+1</span> </div> <p><span id=t24></span></p> <p><span id=t23>Эта строка идентична этому коду:&nbsp;</span></p> <p><span id=t24>If A &lt; 0 And C=2</span></p> <p><span id=t24>B = 2</span></p> <p><span id=t24>C=3</span></p> <p><span id=t24>R:+5</span></p> <p><span id=t24>Else</span></p> <p><span id=t24>A=1</span></p> <p><span id=t24>C:+1</span></p> <p><span id=t24>End if</span></p> <p><span id=t24><span id=t23><strong><em>Замечание:</em></strong> “<strong>End if</strong>”&nbsp;может быть написан как&nbsp;“<strong>EndIf</strong>”</span></span></p> <p><span id=t24></span>&nbsp;</p> <p><span id=t24><span id=t13><strong><a name=b7><span id=t24><span id=t13><strong>Then</strong></span></span></a></strong></span></span></p> <p><span id=t23>&nbsp; Когда-же тогда использовать<span id=t13><strong>Then</strong></span>? Лично я почти никогда не использую "<span id=t13><strong>Then</strong></span>", потому что это не необходимо и код так-же легко читается и без "<span id=t13><strong>Then</strong></span>". Как&nbsp; <font id=t30>If A = 1 then B = 2</font> идентично <font id=t31>If A = 1 B = 2</font><font id=t25>. Если ты возьмешь файл исходника <strong>BlitzMax</strong> и удалишь там все "<span id=t13><strong>Then</strong></span>" ничего, собственно, не изменится. Используй "<span id=t13><strong>Then</strong></span>", если это помогает тебе читать код.</font></p></span> <p><span id=t23></span>&nbsp;</p> <p><span id=t23><span id=t22><strong><em><a name=b8><span id=t23><span id=t22><strong><em>Not True&nbsp;или &lt;&gt; False?</em></strong></span></span></a></em></strong></span></span></p> <p><span id=t23>&nbsp; <strong><em>True</em></strong>(правда) и <strong><em>False</em></strong>(совсем не правда)<strong><em> </em></strong>могут использоваться в&nbsp;<strong>If</strong>-структурах, обучно используются для удобочитаемости, это не необходимо*. <strong><em>False </em></strong>значит, что что-то равно <strong>0</strong>, <strong><em>True </em></strong>- если что-то не равно <strong>0</strong>. Многие функции возвращают <strong>1</strong>, если операция проведена успешна, и <strong>0</strong>, если нет. В <strong>if</strong>-структурах это может быть использованно так:</span></p> <p><span id=t23><span id=t24>If Keydown(Space) = True</span><span id=t24> Then </span></span></p> <p><span id=t23><span id=t24>&nbsp; A = 10 </span></span></p> <p><span id=t23><span id=t24>Else </span></span></p> <p><span id=t23><span id=t24>&nbsp; A = 0 </span></span></p> <p><span id=t23><span id=t24><font id=t25><font id=t27>End If</font> &nbsp; </span></span></p> <p><span id=t23><span id=t24><font id=t25>Это тоже самое, что и: </span></span></p> <p><span id=t23><span id=t24><font id=t25><span id=t24>If Keydown(Key_Space)</span> &nbsp; </span></span><span id=t23><span id=t24><font id=t25><span id=t24>Then</span> &nbsp; </span></span></p> <p><span id=t23><span id=t24><font id=t25><span id=t24>&nbsp; A = 10</span></p> <p><span id=t24>Else </span></p> <p><span id=t24>&nbsp; A = 0 </span></p> <p><span id=t24>End If </span></font></span></p></span> <p><span id=t23>&nbsp; Так как предпологается “<em> = True</em>”. Можно использовать "<strong><em>Not</em></strong>" после <strong><em>IF</em></strong>, чтобы проверить, что что-то не <strong><em>True</em></strong>(тобиш <strong><em>False</em></strong>), как например<span id=t24>If Keydown(Key_Space) = False Then</span><span id=t23>...</span>&nbsp;может быть написано как:</span></p> <p><span id=t23><span id=t24>If Not Keydown(Key_Space) Then</span><span id=t23>...</span>, что означает одно и тоже.&nbsp;Точно также можно проверять и объекты, если объект равен "<strong>null</strong>"(не существует), то <strong><em>False</em></strong>, иначе <strong><em>True</em></strong>.&nbsp;</span></p> <p><span id=t23></span>&nbsp;</p> <p><span id=t23><span id=t22><strong><em><a name=b9><span id=t23><span id=t22><strong><em>Графика: Начало</em></strong></span></span></a></em></strong></span></span></p> <p>&nbsp;<span id=t23><strong><em>DrawRect</em></strong>, <strong><em>DrawOval</em></strong>, <strong><em>DrawLine</em></strong>, <strong><em>DrawText</em></strong>&nbsp;и <strong><em>Plot</em></strong> - несколько встроенных графических комманд. Они просто рисуют закрашенный Прямоугольник/овал, линию, текст и точку соответственно. Если ты хочешь узнать, как использовать эти комманды, смотри <strong>Module Reference</strong>(Описание Модуля). Чтобы использовать видеокарту нужно установить графический режим и определить разрешение, которое ты хочешь использовать. Просто напиши<span id=t23><font id=t30>Graphics 800,600</font> для полноэкранного окна разрешением в <strong>800x600</strong>.</span></span></p> <p>&nbsp;</p> <p><span id=t32>*<font>В </font></span><span id=t13>BlitzMax&nbsp;нет Boolean(булевых)&nbsp;переменных, которые могут быть равны&nbsp;только&nbsp;True&nbsp;и False.</span></p> <p><b><span id=t3></span></b></p> <p><span id=t5></span>&nbsp;</p><span id=t5> <p id=t4><span id=t5><a name=p4><span id=t5>4</span></a></span></p> <p><b><i><span id=t22><a name=b10><b><i><span id=t22>Циклы</span></i></b></a></span></i></b></p> <div></span><font id=t33>&nbsp;&nbsp;Цикл - это способ заставить <strong>Blitz</strong> делать одно действие несколько раз, или&nbsp;в играх - обновлять игру, пока она не закончилась. Циклы - это то, что делает наши игры исполняемыми-в-реальном-времени. Следующий цикл начинается с<span id=t24>Repeat&nbsp; </span>и, когда,&nbsp;компилятор дойдет до<span id=t24>Until X &gt;= 600 </span>, он прыгнет назад к <em>repeat</em>, и будет так делать, пока условие(<font id=t27>X &gt;= 600</font>) не выполнится.</font> </div> <p><span id=t5></span>&nbsp;</p><span id=t5> <p><span id=t24>Graphics 800,600 'Ставим графический режим</span></p> <p><span id=t24>Repeat</span></p> <p><span id=t24>DrawRect X,40,10,12 ', Где&nbsp;40&nbsp;- Y координата, 10 - ширина прямоугольника&nbsp;и 12 - его высота</span></p> <p><span id=t24></span></p> <p><span id=t24>X:+1 'Увеличиваем X&nbsp;на 1&nbsp;с каждым повторением цикла</span></p> <p><span id=t24>Flip' Показываем, что мы нарисовали</span></p> <p><span id=t24>Until X &gt;= 600 'Выходим из цикла,&nbsp;если&nbsp;X&nbsp;больше или равно&nbsp;600</span></p> <p><span id=t24></span>&nbsp;</p> <p><span id=t24><font id=t27><span id=t23>&nbsp; Нажми&nbsp;F5, чтобы скомпилировать и запустить пример. Код мыше создаст "строку степени загрузки" в верху экрана. Если вставить<span id=t24>Cls </span>на новой строке после <strong><em>Flip</em></strong>, то получится не линия, а квадратик, пробегающий от <strong>0</strong> до <strong>600</strong>, измеряемых в пикселях.&nbsp;Также можно заменить<span id=t24>DrawRect </span>&nbsp;на<span id=t24>DrawOval </span>&nbsp;и &nbsp;догодайся что получится...</span></font></span></p> <p><span id=t24></span></span>&nbsp;</p> <p><span id=t24><span id=t22><strong><em><a name=b11><span id=t24><span id=t22><strong><em>Flip&nbsp;и Clear</em></strong></span></span></a></em></strong></span></span></p> <p>&nbsp;&nbsp;В<span id=t23> BlitzMax всё что ты рисуешь рисуется на "невидимом экране". Ты можешь рисовать на нем&nbsp;сколько хочешь, но реально ничего не увидешь. Можно представить, что <strong>BlitzMax</strong> рисует на "обратной стороне" реального экрана(на который ты сейчас смотришь), и когда ты хочешь увидеть, что ты нарисовал, переворачиваем(Flip-аем) Экран и, воаля, ты видишь, что нарисовал.&nbsp;Если мы будем много&nbsp;рисовать, то экран&nbsp;превратится в неразбериху. Вот почему мы&nbsp;очищаем экран каждый раз после того, как мы его перевернули, но из этого следует, что мы должны каждый раз всё&nbsp;заново рисовать.&nbsp;Так&nbsp;оно и работает. "Обратная сторона" экрана&nbsp;называется "<em>задним буфером</em>"(<strong>backbuffer</strong>). Тебе не нужно(и нельзя) поставить <strong>backbuffer</strong>&nbsp;как ты это делал в <span id=t23><strong>Blitz3D</strong>/<strong>BlitzPlus</strong></span>. Такой метод с переворачиванием и отчисткой называется Двойная Буферизация(<strong>Double Buffering</strong>), и используется&nbsp;для избежания&nbsp;ненужных эффектов&nbsp;мигания.</span></p> <p>&nbsp;</p> <p><span id=t22><strong><em><a name=b12><span id=t22><strong><em>Координатная система.</em></strong></span></a></em></strong></span></p> <p><span id=t23>&nbsp;&nbsp;Тут всё также как и в <strong>BlitzBasic</strong>. В верхнем левом углу экрана точка <strong>0</strong>,<strong>0</strong>.&nbsp;Вставь эти строки в предыдущий пример, прямо над “<span id=t24>Repeat</span><span id=t23>”:</span></span></p><span id=t23><span id=t23> <p><span id=t24>Plot 0,0 'Рисует точку в верхнем левом угле экрана.&nbsp;Попробуй также&nbsp;1,1</span></p> <p><span id=t24>Plot 200,200 'Рисует точку в&nbsp;200,200, Читай:&nbsp;точка в&nbsp;X:200, Y:200</span></p> <p><span id=t24><span id=t23>Ось-X - Горизонтальная ось от левой стороны экрана до правой, ось-Y&nbsp;идет сверху вниз. Разрешение определяет количество точек в каждой из&nbsp;этих&nbsp;осях. Так, в&nbsp;моем примере,&nbsp;<em>ScreenWidth</em> будет <strong>800</strong> и <em>ScreenHeight</em> - <strong>600</strong>. Чем больше пикселей на экране - тем больше вычислений требуется для прорисовки экрана как в <strong>2D</strong>, так и в <strong>3D</strong>. Комманда <strong><em>Line</em> X1</strong>,<strong>Y1</strong>,<strong>X2</strong>,<strong>Y2</strong> рисует линию от <strong>X1</strong>,<strong>Y1</strong> до <strong>X2</strong>,<strong>Y2</strong>. Добавь следуещее в пример:</span></span></p><span id=t24><span id=t23> <p><span id=t24>DrawLine 40,40,80,80 ;DrawLine 40,40,40,200</span></p> <p><span id=t24></span><span id=t23>(Замечание:&nbsp;Символ&nbsp;<font id=t27>;</font> позваляет&nbsp;писать несколько комманд в одну строку</span><span id=t23>)</span></p></span></span></span></span> <p><span id=t23></span>&nbsp;</p> <p id=t4><span id=t23><span id=t5><a name=p5><span id=t23><span id=t5>5</span></span></a></span></p> <p><b><i><span id=t22><a name=b13><b><i><span id=t22>Ввод</span></i></b></a></span></i></b></p></span> <p><span id=t23>&nbsp; Ввод - очень простая часть <strong>BlitzMax</strong>. Если ты понял&nbsp;пример&nbsp;про&nbsp;цикл, то это будет как два пальца... вобщем просто.(прим. пер.).(Тут имеется ввиду ввод с мышки и клавиатуры, а не комманда <strong><em>Input</em></strong>)</span></p> <p><span id=t24>Graphics 800,600</span></p> <p><span id=t24>X=500;Y=500' &lt;--- Начальная позиция</span></p> <p><span id=t24>' - - - - - - - - - - Начало_цикла- - - - - - - - - - - - -</span></p> <p><span id=t24>While Not KeyDown(Key_Escape)'Тоже самое, что и Repeat, просто условие пишется вверху</span><span id=t24>.</span></p> <p><span id=t24>'Рисуем____________________________________________</span></p> <p><span id=t24>DrawOval X,Y,8,8 'Рисуем овал(сдесь -&nbsp;круг) в&nbsp;X,Y&nbsp;с диаметром&nbsp;8</span></p> <p><span id=t24>DrawText "Жми стрелки на клавиатуре, чтобы ездить,&nbsp;Пробел&nbsp;в центр",20,20</span></p> <p><span id=t24>'Ввод_______________________________________</span></p> <p><span id=t24>If KeyDown(Key_Left) X:-1 'Уменьшаем X &lt;--&nbsp;Ехать влево</span></p> <p><span id=t24>If KeyDown(Key_Right) X:+1 'Увеличиваем X --&gt;&nbsp;Ехать вправо</span></p> <p><span id=t24>If KeyDown(Key_Down) Y:+1 'Увеличиваем Y&nbsp;Ехать вниз&nbsp;\/</span></p> <p><span id=t24>If KeyDown(Key_Up) Y:-1 'Уменьшаем Y&nbsp;Ехать вверх&nbsp;/\</span></p> <p><span id=t24>IfKeyHit(Key_Space)X=400;Y=300 ‘&nbsp;Ставим позицию(в центр)</span></p> <p><span id=t24>Flip;Cls</span></p> <p><span id=t24>Wend</span></p> <p><span id=t24>' - - - - - - - - -- - -&nbsp;Конец_цикла - - - - - - - - - - - - -</span></p> <p><span id=t23><span id=t23></span></span>&nbsp;</p> <p><span id=t23><span id=t23>Чтобы оптимизировать этот код добавь переменную <em>speed</em> после <span id=t24>Graphics</span>, но до цикла.&nbsp; Теперь замени все единицы на эту новую переменную <em>speed</em>. Найди теперь место, где ты задал переменную <em>speed</em>(вверху) и поставь её равной 5. Если ты всё сделал правильно, то скорость передвижения кружка увеличится. Заметь также, что у всех клавиш есть имена, начинающиеся с <strong>Key_</strong>. Клавиша <strong><em>Z</em></strong> имеет имя <strong><em>Key_Z</em></strong> и так для всех клавиш. Смотри секцию сканкодов в мануале - там есть все кнопки.</span></span></p> <p><span id=t23></span>&nbsp;</p> <p><span id=t23><span id=t22><strong><em><a name=b14><span id=t23><span id=t22><strong><em>Функции</em></strong></span></span></a></em></strong></span></span></p> <p><span id=t3><span id=t23>&nbsp;&nbsp;Функции - это способ использовать&nbsp;несколько раз один и тот-же код. Они помогают тебе разбить код на легко проверяемые&nbsp;кусочки. Функции выглядят так:</span></span></p><span id=t3><span id=t23> <p><span id=t24>Function Collectdata$(Name$,Id%,Age%)' $&nbsp;значит String,%&nbsp;значит Int</span></p> <p><span id=t24>TotalData$ = "Имя: "+Name+" ID: "+id+" Возраст: "+Age</span></p> <p><span id=t24>Return TotalData</span></p> <p><span id=t24>End Function</span></p></span></span> <p><span id=t23>Чтобы использовать эту функцию я должен вписать <em>имя</em>, <em>ID</em> и <em>возраст</em>. Открой пример ввода и впиши эту строку после <span id=t24>Graphics</span>&nbsp;, но до <span id=t24>While</span>:</span></p> <p><span id=t23><span id=t24>TestData$ = Collectdata("Blast",8,30)</span></span></p> <p><font id=t34><font><em>Имя</em>, <em>ID</em> и <em>возраст</em> - это <strong><em>параметры</em></strong> функции <strong>Collectdata()</strong>. Функция возвращает Строку. Функции в <strong>BlitzMax</strong> могут возвращать любой тип данных, включая объекты и массивы(В <strong>BlitzMax</strong> массивы - это объекты).</font></font></p> <p><font id=t33></font>&nbsp;</p> <p id=t4><font id=t33><span id=t5><a name=p6><font id=t33><span id=t5>6</span></font></a></span></font></p> <div><span id=t23>Вот ещё пример простой фунуции:</span><font id=t33> </div> <p><span id=t24>'---------------------&nbsp;Сумма ----------------------</span></p> <p><span id=t24>' Параметры: A,B,C ; складываемые&nbsp;числа</span></p> <p><span id=t24>' Возвращает:&nbsp;Сумму этих чисел</span></p> <p><span id=t24>' Замечания:&nbsp;только целые числа</span></p> <p><span id=t24>'_______________________________</span></p> <p><span id=t24>Function Add( A% , B% , C% = 0 )</span></p> <p><span id=t24>Return A + B + C</span></p> <p><span id=t24>End Function</span></p> <p><span id=t24>'-------------------------------------------------------</span></p></font><font id=t33> <p><span id=t23><em>Number</em> <strong>=</strong> <strong><em>Add(2,2,3)</em></strong>'&nbsp;Number&nbsp;будет равен&nbsp;7</span></p> <p><span id=t23><em>Number</em> <strong>=</strong> <strong><em>Add(2,2)</em></strong>'&nbsp; Number&nbsp;будет равен&nbsp;4</span></p></font> <p><font id=t33>Заметь <em>C=0</em> в параметрах, что означает, что если функции будет предоставленно только 2 значения, <strong><em>C </em></strong>будет равным <strong>0</strong>. Если-бы в параметрах было не&nbsp;<strong><em>C% = 0</em></strong>, а <strong><em>C%</em></strong>, то <span id=t35><strong><em>Add(2,2) </em></strong>вызвало-бы ошибку компиляции, но всё работало-бы нормально при <strong><em>Add(9,9,9)</em></strong>. Заметь, что комментировать свои функции очень важно. Пиши какие параметры используются, что функция возвращает и что она делает. Всегда&nbsp; старайся не делать функции длиннее страницы. Если они становятся слишком длинными, то попробуй разбить их на несколько функций поменьше. Функции могут&nbsp;вызываться из других функций. В больших программах обилие комментарьев и широкая система функций спасет много твоего времени!</span></font></p> <p><font id=t33><span id=t35></span></font>&nbsp;</p> <p><span id=t36><strong><em><a name=b15><span id=t36><strong><em>Random</em></strong></span></a></em></strong></span></p> <p><span id=t35>&nbsp; Самая полезная комманда - это <strong><em>Rand(A,B)</em></strong>, которая генерирует&nbsp;случайное&nbsp;целое число в промежутке между <strong>A</strong> и <strong>B</strong>(включая концы). Например: <em>Test%</em> <strong>=</strong> <strong><em>Rand(1,3)</em></strong>. Это выражение выставит значение <em>Test% </em>равным <strong>1</strong> или <strong>2</strong> или <strong>3</strong>. Если вызвать <strong><em>Rand(A)</em></strong> с одним параметром <em><strong>A</strong></em>, то&nbsp;сгенерируется число от <strong>0</strong> до <strong><em>A</em></strong>, таким образом&nbsp;</span></p> <p><span id=t35><em>test</em> <strong><em>= Rand(1)</em></strong> вернет или <strong>1</strong> или <strong>0</strong>. Если тебе нужно дробное число используй <strong><em>Rnd()</em></strong> с теми же условиями.(прим. пер.)</span></p> <p><span id=t35></span>&nbsp;</p> <p><b><i><span id=t36><a name=b16><b><i><span id=t36>Массивы</span></i></b></a></span></i></b></p> <p><span id=t35>&nbsp; Массивы - это способ хранить несколько переменных в одном месте.</span></p> <p><span id=t35><span id=t37>Local NameList$[ "Dawn" , "Trac" , "Fire" ,"Nitro" ,"Nex"] </span><span id=t35>' Создает массив из пяти строк</span></span></p> <p><span id=t35><span id=t35>Добавь строку, написанную выше, в пример ввода между инициализацией графики и началом цикла.</span></span></p> <p><span id=t35><span id=t35><span id=t37>Text$ = NameList[2]' </span><span id=t35>получаем значение второго элемента.&nbsp;Отсчет элементов&nbsp;в массивах начинается с 0, так что 'это даст нам "Fire".</span></span></span></p> <p><span id=t35><span id=t35><span id=t37>NameList[0] = "None" </span><span id=t35>' ставим значение нулевого элемента массива равным "None" (он раньше был равен&nbsp;“Dawn”)</span></span></span></p> <p><span id=t35><span id=t35>Массивы - отличнейшая штука, т.к. они могут использоваться в циклах; если ты ещё не добавил строку с заданием массива(<font id=t27>NameList</font>), то сделай это сейчас, также добавь этот код в главный цикл:</span></span></p> <p><span id=t35><span id=t35>&nbsp;</span></span></p><span id=t35><span id=t35> <p><span id=t37>Row% = 0</span></p> <p><span id=t37>For Local Name$ = Eachin NameList</span></p> <p><span id=t37>‘&nbsp;Переменная “Name”&nbsp;будет поочередно хранить каждый элемент массива</span></p> <p><span id=t37>DrawText Name,20,Row*20</span></p> <p><span id=t37>Row:+1</span></p> <p><span id=t38></span></p></span></span> <p><span id=t35><span id=t35><span id=t35>Массив может иметь более одного измерения, <strong><em>Local Grid%[5,5]</em></strong>. Эта строка создаст 2D(двухмерный) массив с именем <strong>Grid</strong>, состоящий из&nbsp;<strong>5</strong>x<strong>5</strong> целых чисел. Это значит, что в нем можно хранить 25 разных значений. Чтобы получить доступ к нужному элементу пиши: <strong><em>A = Grid[X,Y]</em></strong>. Если тебе нужно "пробежать" по всем элементам&nbsp;этого массива и сделать с ними что-нибудь, то используй цикл&nbsp; <strong><em>For..Next</em></strong>. Все элементы массива должны быть одного типа.</span></span></span></p> <p><span id=t37></span>&nbsp;</p><span id=t37> <p id=t4><span id=t39><a name=p7><span id=t39>7</span></a></span></p> <p><span id=t37>For n = 0 To 4</span></p> <p><span id=t37>For i = 0 To 4</span></p> <p><span id=t37>Test[n,i] = Rand(3)'&nbsp;Присваивает каждому элементу массива случайное число от&nbsp;0&nbsp;до 3</span></p> <p><span id=t37>Next</span></p> <p><span id=t37>Next</span></p> <p><span id=t37></span>&nbsp;</p></span> <p><span id=t35>Ты можешь создавать многомерные массивы так:</span></p><span id=t35> <p><span id=t37>My_map%[][] = [ [1,1,1],[1,1,2],[2,3,4] ] </span><span id=t35>‘Создает 3x3 массив с&nbsp;определением всех элементов</span></p> <p><span id=t35>Я&nbsp;редко&nbsp;использую массивы. Я так делаю, потому что у <strong>BlitzMax</strong> есть другой способ хранения информации. Способ этот очень гибкий и обеспецивает простоту объектно и не объектно ориентированного программирования.</span></p></span> <p>&nbsp;</p> <p><span id=t36><strong><em><a name=b17><span id=t36><strong><em>Типы</em></strong></span></a></em></strong></span></p> <p><span id=t36><strong><em>&nbsp;&nbsp; </em></strong><span id=t35>Тип - это как структура или план переменных. Это как скелет, который определяешь ты и затем используешь для каждого создоваемого тобой&nbsp;животного(читай - объекта). Тип - часть <strong>BlitzMax</strong>, которая делает его <strong>ОО</strong>(<strong>О</strong>бъектно <strong>О</strong>риентированным) языком программирования.&nbsp;Типы - это самая сложная штука, с которой придется разобратся, если ты новичек в <strong>ООП</strong>. Создай новый файл, если хочешь потестить примеры, идущие далее.</span></span></p> <p>&nbsp;</p> <p><span id=t40><strong><span id=t40><strong><span id=t40><strong></a><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><a name=b18><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong>Установка&nbsp;и&nbsp;Создание&nbsp;типов (объектов)</strong></span></strong></span></strong></span></strong></span></strong></span></a></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></p> <p><span id=t35><span id=t35>&nbsp; Скажем, тебе надо создать&nbsp;космический корабль(далее <em>флаер</em>), так создадим для него структуру:&nbsp;</span></span></p><span id=t35><span id=t35> <p><span id=t37>Type Spaceship 'Декларируем новый тип</span></p> <p><span id=t37>‘Вот сама структура:</span></p> <p><span id=t37>Global Fleet$</span></p> <p><span id=t37>Field MaxSpeed#</span></p> <p><span id=t37>Field Armor%=2000</span></p> <p><span id=t37>Field Name$</span></p> <p><span id=t37>End Type'&nbsp;Конец декларирования</span></p> <p><span id=t35>Это тоже самое, что и&nbsp;:</span></p> <p><span id=t37>Type Spaceship 'Декларируем новый тип</span></p> <p><span id=t37>Global Fleet:String</span></p> <p><span id=t37>Field MaxSpeed:Float</span></p> <p><span id=t37>Field Armor:Int=2000</span></p> <p><span id=t37>Field Name:String</span></p> <p><span id=t37>End Type' Конец декларирования</span></p></span></span> <p><span id=t35><span id=t35>'Теперь мы готовы для создания самого флаера, который будет являтся примером(экземпляром) нашей 'структуры&nbsp;</span></span></p> <div><span id=t37>Ship:Spaceship = New SpaceShip</span> </div> <p><span id=t35><span id=t35><span id=t35>Чтобы получить доступ к этому новому экземпляру&nbsp;<strong>SpaceShip</strong>, названному&nbsp;<strong>ship</strong> используется точка, читать её можно, как "шаг внутрь".</span></span></span></p><span id=t35><span id=t35> <p><span id=t37>Ship.MaxSpeed = 3.5 ‘Читай: Значение&nbsp;MaxSpeed экземпляра&nbsp;Ship...</span></p> <p><span id=t37>Ship.Armor = 5000</span></p> <p><span id=t37>Ship.Name = "Wavebreaker"</span></p></span></span> <p><span id=t35><span id=t35><span id=t35>Выше я задал переменную <strong>ship</strong> для использования структуры <strong>SpaceShip</strong>. Затем я создал флаер, являющийся объектом(экземпляр(пример) <strong>SpaceShip</strong>) и положил этот флаер(его адрес) в переменную <strong>ship</strong>. Теперь я могу устанавливать значения полей этого объекта используя <span id=t35>Ship<i>.Имя_поля.</i></span></span></span></span></p> <p><span id=t37><span id=t35>'Создадим ещё один флаер:</span></span></p> <div><span id=t37>Ship2:Spaceship = New SpaceShip</span> </div> <p>&nbsp;</p> <p id=t4><span id=t39><a name=p8><span id=t39>8</span></a></span></p> <div><span id=t37>Ship2.MaxSpeed = 7.5</span> </div> <p><span id=t35>'Будем использовать значение armor по умолчанию(смотри тип SpaceShip)</span></p> <p><span id=t37>Ship2.Name = "Starbreaker"</span></p> <p><span id=t35>'Теперь у меня есть два объекта типа <strong>SpaceShip</strong>, <strong>Ship</strong> и <strong>Ship2</strong>. Я могу всегда использовать эти переменные как и&nbsp;простые. <strong>If Ship.MaxSpeed &gt; 200 then</strong>... Кстати, если бы я поставил <strong>Ship2 = Ship</strong>, то и <strong>Ship2</strong> и <strong>Ship</strong> ссылались бы на <strong>Ship</strong>, в таком случае <strong>Ship2</strong> будет потерян и будет автоматически удален <strong>BlitzMax</strong>-ом.</span></p> <p><span id=t35>Ship/Ship2 - это <em>адреса</em> к этим новым объектам.</span></p> <p><span id=t37>SpaceShip.Fleet = "Quantum Light" </span><span id=t35>‘ставим глобальную типовую переменную из самого типа</span></p> <p><span id=t37>Print Ship.Name</span></p> <p><span id=t37>Print Ship.MaxSpeed</span></p> <p><span id=t37>Print Ship.Armor</span></p> <p><span id=t37>Print Ship.Fleet</span></p> <p><span id=t37>Print "---------------"</span></p> <p><span id=t37>Print Ship2.Name</span></p> <p><span id=t37>Print Ship2.MaxSpeed</span></p> <p><span id=t37>Print Ship2.Armor</span></p> <p><span id=t37>Print Ship2.Fleet</span></p> <div><span id=t35>Посмотри на&nbsp;&nbsp;<strong><em>Global Fleet$</em></strong>. Так как <strong>Fleet</strong> в типе <em>SpaceShip</em> объявлена как глобальная, то её значение делится между всеми экземплярами <em>SpaceShip</em>. Если один <em>SpaceShip</em> поменяет свой <strong>Fleet</strong>, то то-же самое произойдет и со всеми&nbsp;другими <em>SpaceShip</em>-ами. С константами дело обстоит точно также, за исключением того, что их значения нельзя изменять.</span> </div> <p>&nbsp;</p> <p><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><a name=b19><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong><span id=t40><strong>Списки типов</strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></a></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></strong></span></p> <p>&nbsp; <span id=t35>До текущего момента я не использовал типы на полную мощность. Думаю, одна из лучших особенностей типов - это то, что каждый созданный тип может быть положен в список.&nbsp;После этого ты можешь "прокручивать" этот список и делать какие-либо действия с типами, вложенными в него. Если положить типы в список, то не нужно давать им(типам) индивидуальные имена. Создай новый bmx файл.</span></p> <p><span id=t35></span>&nbsp;</p> <p><span id=t35><span id=t37>Global Number_of_Tanks = 10 'Сколько танков создавать</span><span id=t35>?</span></span></p> <p><span id=t35><span id=t35><span id=t35>Существование такой глобальной переменной позволяет легко изменять параметры программы. Теперь давай создадим новый тип с именем <em>Tank</em><strong>:</strong></span></span></span></p> <p><span id=t37>Type Tank</span></p> <p><span id=t37>Field X#,Y#</span></p> <p><span id=t37>Field Dir%, Armor%=100</span></p> <p><span id=t37>FieldSpeed#=0.2,Size%=25</span></p> <p><span id=t37>Global TankNumber=0'Текущее кол-во танков</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>Graphics 800,600</span></p> <div><span id=t37>TankList:TList = CreateList()</span><span id=t35>'Создаем список, чтобы в нем хранить&nbsp;созданные танки</span> </div> <p><span id=t35><span id=t35><span id=t35><span id=t35>'<strong><em>TankList:TList</em></strong>&nbsp;определяет, что переменная&nbsp;<em>TankList</em>&nbsp;- <strong><em>Link-Type</em></strong>(связной тип), <strong><em>CreateList()</em></strong>&nbsp;возвращает</span></span></span></span></p> <p><span id=t35><span id=t35><span id=t35><span id=t35>'<strong><em>Link-Type</em></strong>.</span></span></span></span></p> <p><span id=t35><span id=t35><span id=t35><span id=t35>'Переменная <em>TankList</em> будет использоваться вдальнейшем для добавления, удаления или изменения этого '<strong><em>TList</em></strong>-а.</span></span></span></span></p> <p><span id=t35><span id=t35><span id=t35><span id=t35>'<strong><em>TList</em></strong> - встроенный тип <strong>BlitzMax</strong>-а и он имеет свои собственные <em>функции</em> и <em>методы</em>.</span></span></span></span></p> <p><span id=t35><span id=t35><span id=t35></span></span></span>&nbsp;</p> <p id=t4><span id=t35><span id=t35><span id=t35><span id=t39><a name=p9><span id=t35><span id=t35><span id=t35><span id=t39>9</span></span></span></span></a></span></span></span></span></p> <div><span id=t35>' Создадим группу новых танков</span><span id=t35><span id=t35><span id=t35><font id=t41> </div> <p><span id=t37>For Nr = 1 To Number_of_Tanks </span><span id=t35>' <em>Number_of_Tanks</em>&nbsp;это глобальная переменная</span></p> <p><span id=t37>Local NewTank:Tank </span><span id=t35>'Декларируем переменную для хранения Танк-типа</span></p> <p><span id=t37>NewTank = New Tank </span><span id=t35>'Записываем адрес нового танка в эту переменную</span></p> <p><span id=t35>'Определяем поля нового&nbsp;<em>Tank</em>-а</span></p> <p><span id=t37>NewTank.Armor = 150 + Rand(1,5)*10 </span><span id=t35>'Ставим случайное значение&nbsp;<em>Armor</em> 10,20,30,40&nbsp;или 50</span></p> <p><span id=t37>NewTank.X = Rand(5,800) ;NewTank.Y = Rand(5,600)</span><span id=t35>'От-фанорейное(случайное) <em>Start Location</em></span></p> <p><span id=t37>NewTank.Dir = Rand(0,360)</span></p> <p><span id=t37>ListAddLast TankList,NewTank </span><span id=t35>'&nbsp;Добавляем этот танк с именем&nbsp;<em>NewTank</em>&nbsp;в <em>TankList</em></span></p> <p><span id=t37>Tank.TankNumber:+1 </span><span id=t35>'Увеличиваем количество танков</span></p> <p><span id=t37>Next</span></p> <p><span id=t37>While Not KeyDown(Key_Escape)</span></p> <p><span id=t37>For T:Tank = EachIn TankList </span><span id=t35>'<em>Local T</em>&nbsp;декларируется, чобы хранить текущий&nbsp;<em>Tank</em>&nbsp;этого цикла</span></p> <p><span id=t37>DrawRect(T.X,T.Y,T.Size,T.Size)</span></p> <p><span id=t37>DrawText "Количество танков&nbsp;: "+Tank.TankNumber,20,20</span></p> <p><span id=t37>T.X:+T.Speed*Cos(T.Dir)</span></p> <p><span id=t37>T.Y:+T.Speed*Sin(T.Dir)</span></p><span id=t37> <p><span id=t37>Next </span><span id=t35>'Этот цикл будет выполнятся для каждого <em>Tank</em>, добавленного в&nbsp;<em> TankList</em></span> </p> <p>Flip ;Cls </p> <p>Wend</p> <p><span id=t37><font id=t45>Так можно изменять все танки в цикле <strong><em>For…Eachin</em></strong>.</font></span> </p></span></font></span></span></span> <p><span id=t35><span id=t35><span id=t35></span></span></span>&nbsp;</p> <p><span id=t37><font id=t45></font></span>&nbsp;</p> <p><span id=t37><font id=t45><span id=t40><strong><span id=t37><font id=t45><span id=t40><strong><span id=t37><font id=t45><span id=t40><strong><span id=t37><font id=t45><span id=t40><strong><a name=b20><span id=t37><font id=t45><span id=t40><strong><span id=t37><font id=t45><span id=t40><strong><span id=t37><font id=t45><span id=t40><strong><span id=t37><font id=t45><span id=t40><strong>Методы</strong></span></font></span></strong></span></font></span></strong></span></font></span></strong></span></font></span></a></strong></span></font></span></strong></span></font></span></strong></span></font></span></strong></span></font></span></p> <p><span id=t37><font id=t45><span id=t35>&nbsp; У типов кроме <strong><em>Global</em></strong>, <strong><em>Const</em></strong> и <strong><em>Field</em></strong>-ов есть ещё <em>методы</em> и <em>функции</em>. Метод - это обычно "действие" типа, например <strong><em>Выстрел()</em></strong> или <strong><em>Взрыв()</em></strong> или <strong><em>Поворот()</em></strong> или <strong><em>Обновление()</em></strong>. Отличие между <em>методами</em> типов и <em>функциями</em> типов это то, что <em>методы</em> используют сам тип и, следовательно, погут обращаться к полям типа напрямую. Можно также использовать <strong>Self</strong><em>.Field,</em> что я бы не рекоммендовал делать(т.к. так длиннее).</span></font></span></p><span id=t37><font id=t45></font></span> <p><span id=t37>Type Wizard</span></p> <p><span id=t37>Field X%,Y%,Mana%</span></p> <p><span id=t37>Method Teleport(X1%,Y1%)</span></p> <p><span id=t37>X=X1;Y=Y1</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>End Type</span>&nbsp;</p> <p><span id=t35>Это тоже самое, что и:</span></p><span id=t35> <p><span id=t37>Type Wizard</span></p> <p><span id=t37>Field X%,Y%,Mana%</span></p> <p><span id=t37>Method Teleport(X1%,Y1%)</span></p> <p><span id=t37>Self.X=X1;Self.Y=Y1</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>End Type</span></p> <div></span><font id=t33>Я&nbsp;изменил пример с танками так, чтобы он мог поддерживать методы:</font> </div> <p><span id=t35><span id=t37>Global Number_of_Tanks = 10 </span><span id=t35>'Сколько танков создовать?</span></span></p> <p><span id=t35></span>&nbsp;</p> <p id=t4><span id=t35><span id=t39><a name=p10><span id=t35><span id=t39>10</span></span></a></span></p> <p><span id=t37>Type Tank</span></p> <p><span id=t37>Field X#,Y#</span></p> <p><span id=t37>Field Dir%,Armor%=100</span></p> <p><span id=t37>FieldSpeed#=0.2,Size%=25</span></p> <p><span id=t37>Global TankNumber=0 </span><span id=t35>'Текущее кол-во танков</span></p> <p><span id=t37>Method Draw() DrawRect X,Y,Size,Size End Method </span><span id=t35>'&lt;---&nbsp;метод</span></p> <p><span id=t37>Method Go() X:+Speed*Cos(Dir); Y:+Speed*Sin(Dir) End Method</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>Graphics 800,600</span></p> <p><span id=t37>TankList:TList = CreateList() </span><span id=t35>'Создаем список для хранения всех танков</span></p> <p><span id=t37>For Nr = 1 To Number_of_Tanks</span></p> <p><span id=t37>Local NewTank:Tank</span></p> <p><span id=t37>NewTank = New Tank</span></p> <p><span id=t37>NewTank.Armor = 150 + Rand(1,5)*10</span></p> <p><span id=t37>NewTank.X = Rand(5,800) ;NewTank.Y = Rand(5,600)</span></p> <p><span id=t37>NewTank.Dir = Rand(0,360)</span></p> <p><span id=t37>ListAddLast TankList,NewTank</span></p> <p><span id=t37>Tank.TankNumber:+1</span></p> <p><span id=t37>Next</span></p> <p><span id=t35>'</span></p> <p><span id=t37>While Not KeyDown(Key_Escape)</span></p> <p><span id=t37>For T:Tank = EachIn TankList</span></p> <p><span id=t37>T.Draw </span><span id=t35>'&lt;--- Выполняем метод</span></p> <p><span id=t37>DrawText "Количество танков&nbsp;: "+Tank.TankNumber,20,20</span></p> <p><span id=t37>T.Go</span></p> <p><span id=t37>Next</span></p> <p><span id=t37>Flip ;Cls</span></p> <p><span id=t37>Wend</span></p></span> <p><span id=t35><span id=t35>Есть специальный метод, называется&nbsp;<strong><em>New()</em></strong>, он исполняется&nbsp;каждый раз когда мы создаем новый экземпляр типа.&nbsp;</span></span></p> <p> <p><b><span id=t46></span></b>&nbsp;</p> <p></p> <p><b><span id=t46><span id=t40><b><span id=t46><span id=t40><a name=b21><b><span id=t46><span id=t40></a><b><span id=t46><span id=t40><a name=b21><b><span id=t46><span id=t40><b><span id=t46><span id=t40><b><span id=t46><span id=t40><a name=b19><b><span id=t46><span id=t40>Функции в типах</span></span></b></a><a name=b19></span></span></b></span></span></b></span></span></b></a></span></span></b></a><a name=b19></span></span></b></a></span></span></b></a></span></span></b></p> <p><span id=t35>&nbsp; Теперь я расскажу тебе про функции в типах. Следующая функция будет отвечать за создание <em>Tank</em>-а. Методы могут исполнятся только если есть экземпляр типа. Как, например для выполнения метода ты писал:&nbsp;<span id=t35>"<em><strong>T</strong>.Draw()</em>", где <strong><em>T</em></strong> - экземпляр типа.&nbsp;А функции вызываются из самого типа, т.е. " <em><strong>Tank</strong>.Create()</em> ", где <strong><em>Tank</em></strong> - имя самого типа. Таким образом, функции типов можно назвать глобальными(как глобальные переменные типов) методоми этого типа. Помни также, что функции могут быть и автономными. Можно сделать функцию, которая находится вне типа, как ты делал это в <strong>Blitz</strong><em>3D</em>/<em>Plus</em>. Если создаешь список для хранения экземпляров типа, то полезно сделать его частью этого типа.&nbsp;Вот как это выглядит в коде, с добавлением функции создания <strong><em>Create()</em></strong> и добавлением списка типа в его тело:</span></span></p> <p><span id=t35><span id=t35><strong></strong></span></span>&nbsp;</p> <p id=t4><span id=t35><span id=t35><span id=t35><span id=t39><span id=t35><span id=t39><a name=p10><span id=t35><span id=t35><span id=t35><span id=t39><a name=p10><span id=t35><span id=t39>10</span></span></a><a name=p10></span></span></span></span></a></span></span></a></span></span></span></span></p> <p><span id=t35><span id=t35><strong></strong></span></span>&nbsp;</p> <p><span id=t37>Global Number_of_Tanks = 10 </span><span id=t35>'Сколько танков создавать?</span></p> <p><span id=t37>Type Tank</span></p> <p><span id=t37>Field X#,Y#</span></p> <p><span id=t37>Field Dir%</span></p> <p><span id=t37>FieldSpeed#=0.2,Size%=25</span></p> <p><span id=t37>Global TankNumber=0 </span><span id=t35>'Текущие количество танков</span></p> <p><span id=t37>Global TankList:TList</span></p> <p><span id=t37>Method Draw() DrawRect X,Y,Size,Size End Method</span></p> <p><span id=t37>Method Go() X:+Speed*Cos(Dir); Y:+Speed*Sin(Dir) End Method</span></p> <p><span id=t37>Function Create()</span></p> <p><span id=t37>If TankList = Null TankList = CreateList() </span><span id=t35>'&nbsp;Создаем список, если его нет</span></p> <p><span id=t37>NewTank:Tank = New Tank</span><span id=t35>'&nbsp;Создаем <em>Tank</em></span></p> <p><span id=t37>NewTank.Dir = Rand(0,360)</span></p> <p><span id=t37>NewTank.X = Rand(5,800) ;NewTank.Y = Rand(5,600)</span></p> <p><span id=t37>TankList.AddLast(NewTank) </span><span id=t35>'Добовляем новый танк в список</span></p> <p><span id=t37>TankNumber:+1</span></p> <p><span id=t37>End function</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>Graphics 800,600,0</span></p> <p><span id=t37>‘Создаем группу танков</span></p> <p><span id=t37>For Nr = 1 To Number_of_Tanks</span></p> <p><span id=t37>Tank.Create()</span></p> <p><span id=t37>Next</span></p> <p><span id=t37>While Not KeyDown(Key_Escape)</span></p> <p><span id=t37>For T:Tank = EachIn Tank.TankList</span></p> <p><span id=t37>T.Draw</span></p> <p><span id=t37>DrawText "Количество танков&nbsp;: "+Tank.TankNumber,20,20</span></p> <p><span id=t37>T.Go</span></p> <p><span id=t37>Next</span></p> <p><span id=t37>Flip;Cls</span></p> <p><span id=t37>Wend</span></p> <p><span id=t35><strong><em>Замечание:</em></strong> функции типов могут напрямую обращаться к глобальным переменным&nbsp;и константам в своем типе. Так, я не писал ” <strong>Tank.TankNumber = 2</strong> “, ведь&nbsp;можно просто написать:&nbsp;“ <strong>TankNumber = 2</strong> “(т.к. <em>TankNumber</em> - глобальная переменная типа).</span></p> <div><span id=t35><strong><em>Замечание: For Eachin TankList</em></strong> выдаст ошибку, если список ещё не создан. Список создается при создании первого танка.&nbsp;Иногда игра начинается перед тем, как создаются танки(нет ни одного экземпляра типа), в таком случае нужно использовать <strong>if</strong>-структуру перед циклом <strong><em>For </em></strong><span id=t35><strong><em>Eachin TankList</em></strong>:</span></span><span id=t35></span><span id=t35> </div> <p><span id=t37>If TankList</span></p> <p><span id=t37>..eachin TankList Loop</span></p> <p><span id=t37>Endif</span></p></span> <p> <p><span id=t35></span></p> <p><font id=t47></font>&nbsp;</p> <p id=t4><span id=t39><a name=p12><span id=t39>12</span></a></span></p> <p><b><span id=t40><b><span id=t40><a name=b22><b><span id=t40><a name=b22><b><span id=t40>Пара&nbsp;функций и методов&nbsp;TList-а</span></b></a><a name=b22></span></b></a></span></b></a></span></b></p> <p><span id=t37>ListAddLast TankList,NewTank&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;ListAddFirst Твой_Список, Твой_Тип</span></p> <p><span id=t37>TankList.AddLast(NewTank)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Твой_Список.AddFirst(&nbsp;Твой_Тип )</span></p> <p><span id=t35>Эти строки делают одно и тоже. В первом&nbsp;ряду - обычные функции, во втором - функции типа и вызываюися они из списка. Это функции <strong>BlitzMax</strong>-овского типа <strong><em>TList</em></strong>.&nbsp;</span></p> <p><span id=t35>Чтобы получить первый элемент списка нужно писать так:</span></p> <p><span id=t35><span id=t37>My_FirstTank:Tank = Tank( TankList.First() )</span></span></p> <div><span id=t35>последний получается так:</span> </div> <div><span id=t35><span id=t37>My_LastTank:Tank = Tank( TankList.Last() )</span></span> </div> <div><span id=t35><font>Причина, по которой я использовал <em>Tank</em><strong>( … ) </strong>состоит в том, что возвращаемый объект должен быть типа <em>Tank</em> и не каким другим. Следующие строки идентичны предыдущим</font>:</span></div> <div><span id=t35> <p><span id=t37>someObject:Object = TankList.First()</span></p> <p><span id=t37>FirstTank:Tank = Tank(someObject )</span></span><span id=t35>&nbsp;</span></p> <p><span id=t35><span id=t35>Если <em>someObject</em> - не типа <em>Tank</em>, то <em>FirstTank</em> будет равен <strong>null</strong>. Узать больше о этом можно в "<em><strong>кастинге</strong></em>". Код для <strong>TList</strong>-а лежит сдесь: BlitzMax\Mod\Brl.Mod\LinkedList.mod\linkedlist.bmx</span></span></p> <p><span id=t35></span>&nbsp;</p> <p><span id=t35><span id=t40><strong><span id=t35><span id=t40><strong><a name=b23><span id=t35><span id=t40><strong><span id=t35><span id=t40><strong>Массивы в типах</strong></span></span></strong></span></span></a></strong></span></span></strong></span></p> <p><span id=t35>&nbsp; Это может пригодится. Чтобы добавить массив в тип пишится так: </span></p> <p><span id=t35><strong><em>Field Твой_Массив[какие_нибудь_числа]</em></strong>. Я расскажу&nbsp;в чем польза от них.</span></p><span id=t35> <p><span id=t37>Type WarTank</span></p> <p><span id=t37>Field MissileSlot1$,MissileSlot2$,MissileSlot3$</span></p> <p><span id=t37>Field AmmoSlot1%,AmmoSlot2%,AmmoSlot3%</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>'Скажем, унас уже есть список..</span></p> <p><span id=t37>For T.WarTank = Eachin TankList</span></p> <p><span id=t37>Select T.MissileSlot1</span></p> <p><span id=t37>case "Infero Missile"</span></p> <p><span id=t37>If T.AmmoSlot1 &gt; 0 FireMissile(T.X.T.Y,23,11)</span></p> <p><span id=t37>case "Normal Missile"</span></p> <p><span id=t37>If T.AmmoSlot1 &gt; 0 FireMissile(T.X.T.Y,3,100)</span></p> <p><span id=t37>End select</span></p> <p><span id=t37>Select T.MissileSlot2</span></p> <p><span id=t37>case "Infero Missile"</span></p> <p><span id=t37>If T.AmmoSlot1 &gt; 0 FireMissile(T.X.T.Y,23,11)</span></p> <p><span id=t37>case "Normal Missile"</span></p> <p><span id=t37>If T.AmmoSlot1 &gt; 0 FireMissile(T.X.T.Y,3,100)</span></p> <p><span id=t37>End select</span></p> <p><span id=t37>Select T.MissileSlot3</span></p> <p><span id=t37>case "Infero Missile"</span></p> <p><span id=t37>If T.AmmoSlot1 &gt; 0 FireMissile(T.X.T.Y,23,11)</span></p> <p><span id=t37>case "Normal Missile"</span></p> <p><span id=t37>If T.AmmoSlot1 &gt; 0 FireMissile(T.X.T.Y,3,100)</span></p> <p><span id=t37>End select</span></p> <p><span id=t37>Next</span></p></span></span> <p><span id=t35>Этот код -&nbsp;<strong>НЕ</strong> способ как это сделать, потомучто если ты будешь использовать массив, ты сможешь использовать цикл, например:</span></p></div><span id=t35> <p><span id=t37>Type WarTank</span></p> <p><span id=t37>Field Missile$[3]</span></p></span> <p>&nbsp;</p> <p id=t4><span id=t39><a name=p13><span id=t39>13</span></a></span></p> <p><span id=t37>Field Ammo%[3]</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>For T.WarTank = Eachin TankList</span></p> <p><span id=t37>For Slot = 0 to 2 </span><span id=t35>'&lt;-- 3 слота</span></p> <p><span id=t37>Select T.Missile[ Slot ]</span></p> <p><span id=t37>Case "Infero Missile"</span></p> <p><span id=t37>If T.Ammo[Slot] &gt; 0 FireMissile(T.X.T.Y,23,11)</span></p> <p><span id=t37>Case "Normal Missile"</span></p> <p><span id=t37>If T.Ammo[Slot] &gt; 0 FireMissile(T.X.T.Y,3,100)</span></p> <p><span id=t37>End select</span></p> <p><span id=t37>Next</span></p> <p><span id=t37>Next</span></p> <p><span id=t37><span id=t35>Всегда избегай повторений кода, используй циклы и функции везде, где это возможно.</span></span></p> <p>&nbsp;</p> <p><b><span id=t48><b><span id=t48><a name=b24><b><span id=t48><b><span id=t48>Расширение типов</span></b></span></b></a>&nbsp;</span></b></span></b></p> <p><span id=t35>Надеюсь, ты знаешь, что имена&nbsp;<em>полей</em>, <em>глобальных переменных</em>, <em>функций</em> и <em>методов</em> одних типов&nbsp;могут быть такими же как и в других типах.&nbsp;Например, возможно иметь одновременно <strong><em>Car.Create()</em></strong>, <span id=t35><strong><em>Tank.Create()</em></strong> и <strong><em>Animal.Create() </em></strong>- три метода, имеющие одинаковые имена, но совершенно разные.</span></span></p> <p><span id=t35><span id=t49>Я решил, что буду использовать флаер в этом примере, т.к.&nbsp;флаеры&nbsp;давольно часто используются в&nbsp;играх и по ним легко показывать и объяснять структуру типа. Сначала я покажу пример без <em>наследовательности</em>(<em>inheritance</em>), затем преобразую его с её&nbsp;использованием. Надеюсь это упростит понимание <em>наследственности</em>.</span></span></p><span id=t35><span id=t49> <p><span id=t35>'Файтер - маленький и быстрый корабль</span></p><span id=t35> <p><span id=t37>Type Fighter</span></p> <p><span id=t37>Field X#,Y#</span></p> <p><span id=t37>Field Xspeed#,Yspeed#</span></p> <p><span id=t37>Field ID%</span></p> <p><span id=t37>Field Armor%</span></p> <p><span id=t37>Field Fleet$,Name$</span></p> <p><span id=t37>Field WeaponSelected$</span></p> <p><span id=t37>Global Gfx_Ship 'Графика</span></p> <p><span id=t37>Global Gfx_Thrusters</span></p> <p><span id=t37>Global Sfx_Thrust ' Звук</span></p> <p><span id=t37>Global Sfx_Explode</span></p> <p><span id=t37>Field SheildRechargeRate#=0.1</span></p> <p><span id=t37>Field Energy%=500</span></p> <p><span id=t37>Field WeaponUpgrade%</span></p> <p><span id=t37>Field PowerUpgrade%</span></p> <p><span id=t37>Field Fuel%</span></p> <p><span id=t37>Field Scanner</span></p> <p><span id=t37>Method DockWithCruiser()</span></p> <p><span id=t37>...</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>Method SelfDestruct()</span></p> <p><span id=t37>Armor = 0</span></p> <p><span id=t37>PlaySound Sfx_Explode</span></p></span></span></span> <p>&nbsp;</p> <p id=t4><span id=t39><a name=p14><span id=t39>14</span></a></span></p> <p><span id=t37>Explosion( X, Y)</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>Method Update()</span></p> <p><span id=t37>X:+Xspeed ;Y:+Yspeed</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>End Type</span></p> <p><span id=t35>'Краузеры - это здоровенные поддерживающие корабли</span></p> <p><span id=t37>Type Cruiser</span></p> <p><span id=t37>Field X#,Y#</span></p> <p><span id=t37>Field Xspeed#,Yspeed#</span></p> <p><span id=t37>Field ID%</span></p> <p><span id=t37>Field Armor%</span></p> <p><span id=t37>Field Fleet$,Name$</span></p> <p><span id=t37>Field WeaponSelected$</span></p> <p><span id=t37>Global Gfx_Ship 'Графика</span></p> <p><span id=t37>Global Gfx_Thrusters</span></p> <p><span id=t37>Global Sfx_Thrust ' Звук</span></p> <p><span id=t37>Global Sfx_Explode</span></p> <p><span id=t37>Field SheildPower</span></p> <p><span id=t37>Field Reactor$</span></p> <p><span id=t37>Field CrewNR%</span></p> <p><span id=t37>Field TractorBeamUpgrade%</span></p> <p><span id=t37>Field CloakingDeviceON=false</span></p> <p><span id=t37>Field MissileSlots[4]</span></p> <p><span id=t37>Method UseTractor(F:Fighter)</span></p> <p><span id=t37>...</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>Method UseTractor(C:Cruiser)</span></p> <p><span id=t37>...</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>Method SelfDestruct()</span></p> <p><span id=t37>Armor = 0</span></p> <p><span id=t37>PlaySound Sfx_Explode</span></p> <p><span id=t37>Explosion( X, Y)</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>Method Update()</span></p> <p><span id=t37>X:+Xspeed ;Y:+Yspeed</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>End Type</span></p> <p><span id=t35>С использованием&nbsp;<em>наследственности</em> <strong>ООП</strong>, я бы сначала создал тип <em>Ship</em>, а&nbsp;затем расширил бы этот тип в Краузер(<font id=t27>Cruiser</font>) и Файтер(<font id=t27>Fighter</font>). Можно поступить ещё глобальнее - создать тип <em>SpaceObject</em>(космический_Объект), а <em>Ship</em> - может расширять его.</span></p> <p><span id=t37>Type Ship</span></p> <p><span id=t37>Field X#,Y#</span></p> <p>&nbsp;</p> <p id=t4><span id=t39><a name=p15><span id=t39>15</span></a></span></p> <p><span id=t39></span>&nbsp;</p><span id=t39> <p><span id=t37>Field Xspeed#,Yspeed#</span></p> <p><span id=t37>Field ID%</span></p> <p><span id=t37>Field Armor%</span></p> <p><span id=t37>Field Fleet$,Name$</span></p> <p><span id=t37>Field WeaponSelected$</span></p> <p><span id=t37>Global Gfx_Ship 'Графика</span></p> <p><span id=t37>Global Gfx_Thrusters</span></p> <p><span id=t37>Global Sfx_Thrust ' Звук</span></p> <p><span id=t37>Global Sfx_Explode</span></p> <p><span id=t37>Method SelfDestruct()</span></p> <p><span id=t37>Armor = 0</span></p> <p><span id=t37>PlaySound Sfx_Explode</span></p> <p><span id=t37>Explosion( X, Y)</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>Method Update()</span></p> <p><span id=t37>X:+Xspeed ;Y:+Yspeed</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>Type Fighter Extends Ship</span></p> <p><span id=t37>Field SheildRechargeRate#=0.1</span></p> <p><span id=t37>Field Energy%=500</span></p> <p><span id=t37>Field WeaponUpgrade%</span></p> <p><span id=t37>Field PowerUpgrade%</span></p> <p><span id=t37>Field Fuel%</span></p> <p><span id=t37>Field Scanner</span></p> <p><span id=t37>Method DockWithCruiser()</span></p> <p><span id=t37>...</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>Type Cruiser Extends Ship</span></p> <p><span id=t37>Field SheildPower</span></p> <p><span id=t37>Field Reactor$</span></p> <p><span id=t37>Field CrewNR%</span></p> <p><span id=t37>Field TractorBeamUpgrade%</span></p> <p><span id=t37>Field CloakingDeviceON=false</span></p> <p><span id=t37>Field MissileSlots[4]</span></p> <p><span id=t37>Method UseTractor(S:Ship) </span><span id=t35>'Принять краузер или файтер(Любой тип, расширяющий <em>ship</em>)</span></p> <p><span id=t37>...</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>End Type</span></p></span> <p><span id=t46><span id=t35>Если посмотреть на расширенный&nbsp;тип <em>Fighter</em>, то у него будут все поля, методы и функции, которые есть в типе <em>ship</em> плюс дополнительные, описанные в расширенном типе <em>Fighter</em>. <span id=t37>F:Fighter = New Fighter<span id=t35>; для программиста полученный файтер будет выглядеть точно так-же, как и файтер в первом примере(без <em>наследственности</em>).&nbsp;В данном примере не так много методов, но даже если ты будешь делать среднюю по размерам игру, то там их будет очень и очень много, и поэтому я очень рекомендую использовать возможности <strong>ООП</strong>. Я также посоветовал бы использовать <strong>ООП</strong> в маленьких играх. Если добавлять тип <em>ship</em> в список каждый раз, когда создается новый корабль, то ты сможешь обновлять не только&nbsp;каждый Ship</span></span></span></span></p> <p> <p><b><span id=t46></span></b>&nbsp;</p> <p></p> <p id=t4><span id=t46><span id=t39><a name=p16><span id=t46><span id=t39>16</span></span></a></span></span></p> <p><span id=t46><span id=t39></span></span>&nbsp;</p> <p><span id=t46><span id=t39></span></span><span id=t35>но и каждый файтер или каждый краузер. Это быстрый и простой способ доступа к множеству&nbsp;объектов в реальном времени.</span></p> <p><span id=t35>Другим плюсом <strong>ООП</strong> является то, что можно легко&nbsp;переносить код с одного проэкта в другой. Скажем ты уже сделал одну игру про космос, и начал делать другую(тоже про космос).&nbsp;Тогда просто скопируй тип <em>Ship</em> в новый файл&nbsp;и юзай уже готовые функции и методы, расширяя их новыми. Ты скоро поймешь(если ещё не понял), что части твоих игр/прог будут почти автономными и могут использоваться в других играх/прогах. Затем можно сделать модуль и использовать его уже как часть <strong>BlitzMax</strong>. Уже есть тьюториал по созданию своего модуля&nbsp;для <strong>BlitzMax</strong>, посмотри его обязательно<font id=t50>.(его я тоже переведу, если у меня&nbsp;самого получится сделать хоть один, т.к. пока не получаеться правильно настроить MinGV.-прим.пер.)</font></span></p> <p><span id=t35></span>&nbsp;</p> <p><span id=t35><span id=t40><strong><a name=b25><span id=t35><span id=t40><strong>Замещение(Override) методов</strong></span></span></a></strong></span></span></p> <p><span id=t35><span id=t35>&nbsp; Если создать тип <em>Car</em>, расширенный из <em>Vehicle</em>, то <em>Car</em> унаследует все методы <em>Vehicle</em>. Ты всё ещё можешь сделать метод в <em>Car</em> с таким же именем как и у метода в <em>Vehicle</em>.&nbsp;Если вызовешь этот метод из <em>Car</em>, то будет использоваться метод, описанный в <em>Car</em>. Если же ты вызовешь его из <em>Vehicle</em>, то будет уже использоваться метод, описанный в <em>Vehicle</em>.&nbsp;Если есть два метода с одинаковым именем в одном и том-же типе, то такое дело называется <em><strong>Замещением Методов</strong></em>. Метод&nbsp;из <em>Car</em> замещает метод из <em>Vehicle</em>. Это также известно как <em><strong>полиморфизм</strong></em>. Это может быть полезно потомучто одна и та же комманда может делать множество разных действий, в зависимости от типа, из которого она вызванна. Ниже будет пример.</span></span></p> <p><span id=t35><span id=t35></span></span>&nbsp;</p><span id=t35><span id=t35> <p><b><span id=t40><a name=b26><b><span id=t40>Self</span></b></a></span></b></p> <p><span id=t35>&nbsp; <em>Self</em> может бытьиспользованно только в методах. Если используешь <em>Self</em>, то оно будет относиться к типу, из которого вызываеться метод. Как, например: <strong><em>C:Car = New Car</em></strong>; <strong><em>C.Run()</em></strong>.&nbsp;В методе <strong><em>Run()</em></strong> <em>Self</em> будет относиться к&nbsp;экземпляру типа <em>Car</em>, известного как <strong><em>C</em></strong>. Таким образом все&nbsp;поля и методы могут быть доступны через Self.<em>Имя_поля</em> вместо <em>Имя_поля</em>,&nbsp;но... это будет бесполезно. Единственное(которое пришло в голову) место, где этот Self можно использовать, то это ситуация, когда у тебя есть функция/метод, которой в качестве параметра требуется твой тип. Скажем, мы внутри метода <strong><em>Run()</em></strong> твоего типа <em>Car</em>, нужно вызвать функцию, которая принимает экземпляры типа <em>Car</em>, чтобы сослаться на текущий экземпляр <em>Car</em>, используй <em>Self</em>, <span id=t35><em><strong>StealTires(Self, Number)</strong>. </em>Можно также вписать <strong><em>C</em></strong> вместо <em>Self</em>, что, как&nbsp;получаеться, становиться&nbsp;ненужным. <em>Self</em> всё равно не сильно нужен, так что если ты не разобрался с <em>Self</em>, то просто его не используй, а если разобрался, то используй его там где считаешь&nbsp;нужным.</span></span></span></span></p> <p> <p><span id=t35></span></p><span id=t37>Type Vehicle</span> <p></p> <p><span id=t37>Global Creator$ = " FX-Factory"</span></p> <p><span id=t37>Field Name$="Vehicle"</span></p> <p><span id=t37>Field Broken=False</span></p> <p><span id=t37>Method Test()</span></p> <p><span id=t37>If Not Broken Print Name+" работает!" Else Print Name+"&nbsp;сломан!"</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>'Self относится к типу, из которого был вызван</span></p> <p><span id=t37>'Пример:</span></p> <p><span id=t37>'Bus.Collide(Train)</span></p> <p><span id=t37>'--&gt; Bus&nbsp;это Self&nbsp;и Train&nbsp;это V (в методе ниже)</span></p> <p><span id=t37>'Пример 2:</span></p> <p><span id=t37>'Train.Collide(Bus)</span></p> <p><span id=t37>'--&gt; Train&nbsp;это Self&nbsp;и Bus&nbsp;это V (В методе&nbsp;Collide)</span></p> <p><span id=t37>Method Collide(V:Vehicle)</span></p> <p><span id=t37>If Car(Self) And Car(V) Print "Car Collide&nbsp;с Car"</span></p> <p><span id=t37>If Car(Self) And Bus(V) Print "Car Collide&nbsp;с Bus"</span></p> <p><span id=t37>If Bus(Self) And Car(V) Print "Bus Collide&nbsp;с Car"</span></p> <p><span id=t37>If Bus(Self) And Bus(V) Print "Bus Collide&nbsp;с Bus"</span></p><span id=t37> <p><span id=t39></span>&nbsp;</p> <p><span id=t39></span>&nbsp;</p> <p id=t4><span id=t39><a name=p17><span id=t39>17</span></a></span></p> <p><span id=t37>Broken=True'Заметь, что&nbsp;Self сдесь не нужен</span></p> <p><span id=t37>V.Broken=True</span></p> <p><span id=t37>EndMethod ‘Если тебе этот метод кажется странным, то посмотри "кастинг", описанный ниже&nbsp;</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>Type Car Extends Vehicle</span></p> <p><span id=t37>Method Test()</span></p> <p><span id=t37>If Not Broken Print "Тачка работает!" Else Print "Тачка сломанна!"</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>Type Bus Extends Vehicle</span></p> <p><span id=t37>Method Test()</span></p> <p><span id=t37>If Not Broken Print "Автобус работает!" Else Print "Автобус сломан!"</span></p> <p><span id=t37>End Method</span></p> <p><span id=t37>Method SuperTest()</span></p> <p><span id=t37>Super.Test() 'Вызывает Test() из&nbsp;Vehicle </span></p> <p><span id=t37>EndMethod</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>‘Чтобы всё проверить</span></p> <p><span id=t37>C:Car = New Car</span></p> <p><span id=t37>B:Bus = New Bus</span></p> <p><span id=t37>B.Collide(C)</span></p> <p><span id=t37>Car2:Car = New Car</span></p> <p><span id=t37>Bus2:Bus = New Bus</span></p> <p><span id=t37>Bus2.Collide(B)</span></p> <p><span id=t37>Car2.Collide(Bus2)</span></p> <p><span id=t37>Car2.Collide(C)</span></p> <p><span id=t37>Car2.Test</span></p> <p><span id=t37>C.Test</span></p> <p><span id=t37>B.Test</span></p> <p><span id=t37>Bus2.Test</span></p> <p><span id=t37>Bus2.SuperTest()</span></p> <p><span id=t35>&nbsp;Чтобы&nbsp;увидеть результат этого примера посмотри закладку <em>output</em> в <strong>IDE</strong>. Этот пример показывает использование кастинга, замещения типов, <em>self</em> и <em>super</em>.</span></p><span id=t35> <p><span id=t39></span>&nbsp;</p> <p id=t4><span id=t39><a name=p18><span id=t39>18</span></a></span></p> <p><b><span id=t40><a name=b27><b><span id=t40>Super</span></b></a></span></b></p> <p><span id=t35>&nbsp; Если у тебя есть замещенная функция или метод <em>КриваяФункция()</em> в расширенном типе, возьмем например <em>Car</em>. Если ты где-то в типе <em>car</em>, его функциях или методах, и хочешь вызвать <em>КриваяФункция()</em> из <em>Vehicle</em>, то нужно писать: <strong><em>Super</em></strong>.<em>КриваяФункция()</em>. Читай <strong><em>Super</em></strong> как: Использовать родительский...</span></p></span></span> <p><b><span id=t46><span id=t40></span></span></b>&nbsp;</p> <p><b><span id=t46><span id=t40><a name=b28><b><span id=t46><span id=t40>Кастинг</span></span></b></a></span></span></b></p> <p><span id=t35>&nbsp; В предыдущем примере я использовал кастинг. Кастинг - это способ проверки объекта на его принадлежность к определенному типу&nbsp;(например, что это <em>car</em> а не <em>bus</em>). Объекты - это экземпляры типов.&nbsp;Если ты, например, создашь <em>car</em>: <em><strong>C</strong>:Car</em> , то <strong><em>C</em></strong>&nbsp;будет объектом. Может получиться так, что тебе потребуется проверить, что есть&nbsp;<strong><em>C</em></strong> - <em>Car, Bus</em> или&nbsp;<em>Vehicle</em>.&nbsp;Ответ очевиден, <strong><em>C</em></strong> - это <em>Car</em> и <em>Vehicle</em> - это не <em>Bus</em>. Кастинг выполняется так: <em>Тип_на_который_нужно_проверить(&nbsp;Экземпляр_объекта )</em>.&nbsp;В примере выше,&nbsp;методе </span></p> <p><span id=t35><strong><em>Collide()</em></strong>, я использовал кастинг, чтобы&nbsp;узнать какой тип у объекта, вызывающего этод метод.&nbsp;В&nbsp;<em><strong>Car(Self)</strong></em> и <strong><em>Bus(Self)</em></strong>. <strong><em>Car(Self)</em></strong> проверяет <em>Self</em> на принадлежность к типу <em>Car</em>. Если <em>Self</em> типа <em>Car</em>, или любого типа, расширяющего <em>Car</em>, то <strong><em>Car(Self)</em></strong>&nbsp;вернет тип-<em>Car</em>, чем в данном случае является <em>Self</em>.</span></p> <p><span id=t35>Ничего не понял?</span></p> <p><span id=t35>Если <em>Self</em> не типа <em>Car</em>, то <strong><em>Car(Self)</em></strong>&nbsp;вернет <strong><em>Null</em></strong> или <strong><em>False</em></strong>. Если возвратился тип <em>Car</em>, который не <strong><em>null</em></strong>, то, следовательно возвратилось <strong><em>True</em></strong>. Вот почему я получаю&nbsp;<strong><em>True</em></strong>, если <em>Self</em> типа <em>Car</em>. Кастинг может быть использован с любыми объектами, <strong>BlitzMax</strong> иногда сам кастингует вещи для тебя, как, например, когда ты присваиваешь числу строку(<strong><em>a%=s$</em></strong>). Если строка начинаеться с чисел, то эти числа будут переведены в это число. Про это говориться в <strong><em>Language Reference</em></strong>(Описании Языка).</span></p> <p><span id=t35>Всё ещё ничего не понял?</span></p> <p><span id=t35>Тогда я бы посоветовал тебе разобрать получше предыдущий пример, попробуй что-нибудь там поменять. Одним из примеров кастинга может служить функция, возвращающая <em>object</em>(объект), который являеться основой всех типов. Все типы, которые ты создаешь расширенные из <em>object</em>.</span></p> <p><span id=t37>testObj:Object = Какая-нибудь_функция_которая_возвращает_Объект()</span></p> <p><span id=t35><span id=t35>Скажем ты хочешь проверить что <em>testObj</em> типа <em>Tank</em>, тогда нужно сделать так:</span></span></p> <p><span id=t37>If Tank(testObj) </span><span id=t35>‘Вернет <strong><em>True</em></strong>&nbsp;если <em>testObj</em>&nbsp;типа <em>Tank</em></span></p> <p><span id=t35><span id=t35>Но если ты хочешь изменить <em>speed</em> танка, то ты не можешь использовать <em>testObj<strong>.Speed</strong></em>. Для начала тебе следует присвоить этому объекту тип Tank. <span id=t37>T:Tank = Tank(testObj)<font id=t45>. Теперь у тебя есть доступ к <strong><em>T.Speed</em></strong>.</font></span></span></span></p> <p><span id=t35></span>&nbsp;</p> <p><span id=t35><span id=t40><strong><a name=b29><span id=t35><span id=t40><strong>Abstract&nbsp;и Final</strong></span></span></a></strong></span></span></p> <p><span id=t35><span id=t35>&nbsp; Если у тебя есть абстрактный(<strong>Abstract</strong>) тип, то ты не сможешь создавать экземпляры этого типа. Что значит, что это весьма бесполезно, но так ли это? Всё ещё можно делать <em>функции</em>, <em>Global</em>-ы и <em>поля </em>в нем. Но доступа к ним нет, пока этот тип не расширить. Польза&nbsp;от таких типов&nbsp;в том, что пользователь(другие программисты и ты)&nbsp;не сможет по ошибке создать экземпляр такого типа, как, например, <em>Vehicle</em>.&nbsp;Зачем, скажешь ты. Как же мне рисовать <em>Vehicle</em>? Как тачку,&nbsp;грузовик или вертолет? <em>Vehicle</em> - абстрактный.&nbsp;Это не запрещает мне создавать тачку, грузовик или что-угодно, расширяющее <em>Vehicle</em>.&nbsp;&nbsp;Единственное, что ты не можешь сделать, это создать экземпляр самого&nbsp;абстрактного типа, <em>Vehicle</em>. Но разве <em>Car</em> не <em>Vehicle</em>. Да, но тип&nbsp;Car не абстрактный и, следовательно можно и рисовать и создовать тачки, которые являются <em>vehicle </em>- ми =)</span></span></p> <p><span id=t35><span id=t35>Скажем, я хочу, чтобы у всех <em>Vehicle</em> был метод <em>Create</em>(создать), так что все <em>Vehicle</em>, которые я буду использовать будут создоваемыми. В таком случае я смогу создать абстрактный метод, который не будет ничего делать, кроме как вылетать на ошибке, если кто-либо попытается сделать расширенный <em>vehicle</em>(как <em>Car</em>) без метода <em>create</em>. <span id=t37>Final</span><span id=t35> же запрещает расширять тип. Скажем, я не хочу, чтобы кто-нибудь расширил Car и если кто-нибудь попытаеться, то получит ошбку. Также можно делать <span id=t37>Final&nbsp;</span>&nbsp;методы, чтобы нельзя было их замещать.&nbsp;</span></span></span></p> <p><span id=t35><span id=t35></span></span>&nbsp;</p><span id=t35><span id=t35> <p id=t4><span id=t39><a name=p19><span id=t39>19</span></a></span></p> <p><b><i><span id=t36><a name=b30><b><i><span id=t36>Частота обновления и Delta Time</span></i></b></a></span></i></b></p></span></span> <p><span id=t35>&nbsp; <span id=t35><strong><em>FPS</em></strong>, Кадров в Секунду(<em><strong>F</strong>rames <strong>p</strong>er <strong>S</strong>econd</em>) - это скорость,&nbsp;на которой обновляется игра. По умолчанию <strong>BlitzMax</strong> пытается обновлять прогу/игру со скоростью равной частоте обновления монитора. </span></span></p> <p><span id=t35><span id=t35>Параметры Graphics:</span></span></p> <p><span id=t35><span id=t35><strong><em>Graphics</em></strong> <em>Ширина</em>, <em>Высота</em>, <em>глубина цвета</em>, <em>частота обновления</em></span></span></p> <p><span id=t35><span id=t35>Ты можешь сам&nbsp;определить частоту обновления, которой <strong>BlitzMax</strong> попытается соответствовать. Маленькая игра типа пинг-понга на быстрых компах без лимитирования <strong>FPS</strong> будет работать так быстро, что&nbsp;мяча не будет видно. Если компьютер слабый, и дает меньше <strong>FPS</strong> чем ты установил, то игра будет&nbsp;работать очень медленно. Есть другой способ использования системных ресурсов на полную мощность, заключающийся в том, чтобы убрать предел <strong>FPS</strong> и использовать логическую систему времени. В таком случае всё равно, на какой системе включена игра, так как везде она будет работать одинаково(ну почти - прим.пер.). Юнит из <strong>А</strong> прийдет в <strong>Б</strong> за одинаковое время. Игра никогда не будет "тормозить", но вместо этогос тебе придется долго думать о системных требованиях. Это дополнительное время можно использовать для различных эффектов и т.п. Наибольшим преимуществом этого способя является то, что если ты однажды поставил скорость объектов в <em>пикселях/секунду</em>, то они всегда будут двигаться на этой скорости, не смотря на <strong>FPS</strong>. Но, для чего тебе нужна задержка(<font id=t50>тут - уменьшение скорости</font>)&nbsp;вместо "торможения"? Для Мультиплэера! В мультиплэере каждый пользователь должен играть в игру на одной скорости. <em>ДельтаТайминг</em>(<strong><em>Delta timing</em></strong>) - лучшее решение для маленьких игр. <em>Дельтатайминг</em> - это слишком сложно? Ответ - нет, но оно требует добавления кода в твою игру. Если установить <em>дельтатайминг</em>&nbsp;в игре, то будет&nbsp;легко изменять её&nbsp;скорость, что иногда бывает очень полезным.&nbsp;Вот пример про танки, но уже с использованием <em>дельтатайминга</em>:</span></span></p> <p><span id=t37>Global Number_of_Tanks = 500 </span><span id=t35>'Сколько танков создавать?</span></p> <p><span id=t37>Const RefreshRate = 85'Hz = FPS</span></p> <p><span id=t35>'Попробуй поменять RefreshRate на 25,85,300</span></p> <p><span id=t37></span></p> <p><span id=t35><span id=t35>'Эта симуляция будет работать на одной и той-же скорости.</span></span></p> <p><span id=t37>Type MoveObject</span></p> <p><span id=t37>Field X#,Y#</span></p> <p><span id=t37>Field Dir%</span></p> <p><span id=t37>'Field Speed%=1</span></p> <p><span id=t37>Global DeltaTime:Double = 0</span></p> <p><span id=t37>Global TimeDelay:Int' Millisecs()&nbsp;возвращает int(целое число)!</span></p> <p><span id=t37>'Нам не надо, чтобы&nbsp;TimeDelay&nbsp;начиналось с 0..</span></p> <p><span id=t37>'New()&nbsp;вызывается, когда кто-либо создает новый объект</span></p> <p><span id=t37>'DefaultField(параметры по умолчанию)&nbsp;могут быть только константами</span></p> <p><span id=t37>Method New() TimeDelay=MilliSecs() EndMethod</span></p> <p><span id=t37>Function UpdateDeltaTime()</span></p> <p><span id=t37>DeltaTime = ( MilliSecs()- TimeDelay )*0.001'Delta Timer</span></p> <p><span id=t37>TimeDelay = MilliSecs()</span></p> <p><span id=t37>End Function</span></p> <p><span id=t37>End type</span></p> <p><span id=t37>Type Tank Extends MoveObject</span></p> <p><span id=t37>'Замещаем Speed&nbsp;из MoveObject</span></p> <p><span id=t37>Field Speed# = 200/1 '&nbsp;Пиксель / Секунда</span></p> <p><span id=t37>Field Size%=5</span></p> <p><span id=t35><span id=t35></span></span>&nbsp;</p> <p id=t4><span id=t35><span id=t35><span id=t39><a name=p20><span id=t35><span id=t35><span id=t39>20</span></span></span></a></span></p> <p><span id=t37>Global TankNumber=0 </span><span id=t35>'Текущее количество танков</span></p> <p><span id=t37>Global TankList:TList</span></p> <p><span id=t35>'Рисуем квадрат в координатах танка</span></p> <p><span id=t37>Method Draw() DrawRect X,Y,Size,Size EndMethod</span></p> <p><span id=t35>'Обновляем движение танка</span></p> <p><span id=t37>Method Go() X:+Speed*Cos(Dir)*DeltaTime; Y:+Speed*Sin(Dir)*DeltaTime EndMethod</span></p> <p><span id=t35>'Устонавливаем начальные значения для нового танка</span></p> <p><span id=t37>Method SetupNew()</span></p> <p><span id=t37>Dir = Rand(0,360)</span></p> <p><span id=t37>X = (GraphicsWidth()/2) ;Y = (GraphicsHeight()/2)</span></p> <p><span id=t37>Speed:*Rnd(0.1,1)</span></p> <p><span id=t37>End Method</span></p> <p><span id=t35>'Эта функция создает новый танк</span></p> <p><span id=t37>Function Create()'</span></p> <p><span id=t37>If TankList = Null TankList = CreateList() '&nbsp;Создаем список, если его нет</span></p> <p><span id=t37>NewTank:Tank = New Tank</span></p> <p><span id=t37>NewTank.SetupNew()</span></p> <p><span id=t37>TankList.AddLast(NewTank)</span></p> <p><span id=t37>TankNumber:+1 '</span></p> <p><span id=t37>End Function</span></p> <p><span id=t37>End Type</span></p> <p><span id=t37>'bglSetSwapInterval( 0 )</span><span id=t35>'&nbsp;Раскомментируй эту строку,&nbsp;чтобы включить максимальную fps</span></p> <p><span id=t37>Graphics 800,600,16,RefreshRate'</span></p> <p><span id=t35>'&nbsp;Создаем новую группу танков.</span></p> <p><span id=t37>For Nr = 1 To Number_of_Tanks</span></p> <p><span id=t37>Tank.Create()</span></p> <p><span id=t37>Next</span></p> <p><span id=t37>While Not KeyDown(Key_Escape)</span></p> <p><span id=t37>MoveObject.UpdateDeltaTime() </span><span id=t35>'Обновляем все&nbsp;MoveObjects</span></p> <p><span id=t37>For T:Tank = EachIn Tank.TankList</span></p> <p><span id=t37>T.Draw</span></p> <p><span id=t37>DrawText "Количество танков&nbsp;: "+Tank.TankNumber,20,20</span></p> <p><span id=t37>T.Go'update</span></p> <p><span id=t37>Next</span></p> <p><span id=t37>Flip;Cls</span></p> <p><span id=t37>Wend</span></p></span></span><span id=t35><span id=t35> <p><span id=t35>Если хочешь&nbsp;добавить дельтатайминг в свою игру, то следуй&nbsp;следующим шагам:</span></p> <p><span id=t35>1. Добавь эти строки в главный цикл</span></p> <p><span id=t37>DeltaTime# = ( Millisecs()- TimeDelay )*0.001 ' Delta Timer</span></p></span></span> <p><span id=t35><span id=t35></span></span>&nbsp;</p><span id=t35><span id=t35> <p id=t4><span id=t39><a name=p21><span id=t39>21</span></a></span></p> <p><span id=t37>TimeDelay = Millisecs()</span></p> <p><span id=t35>Убедись, что <strong><em>DeltaTime</em></strong> и <strong><em>TimeDelay</em></strong> - глобальные переменные. В примере про танки я сделал это способом <strong>ООП</strong>, но это ничего не меняет и ты можешь просто скопировать эти строки в главный цикл. Знаешь почему я умножаю <strong><em>DeltaTime</em></strong> на <strong>0.001</strong>? Это всё потому, что <strong><em>Millisecs()</em></strong> измеряет время в милисекундах, <strong>1000</strong> миллисекунд равны одной секунде. А мы измеряем время в секундах, нам нужно <em>пиксель/секунда</em> а не <em>пиксель/милисикунда</em>. Вот почему следует делить <strong><em>DeltaTime</em></strong> на <strong>1000</strong> или умножать на <strong>0.001</strong>.</span></p> <p><span id=t35>Также убедись, что <strong><em>DeltaTime</em></strong> типа <em>Float</em>&nbsp;или <em>Double</em>! А <strong><em>TimeDelay</em></strong> - <em>int</em>.</span></p><span id=t35> <p><span id=t35>2.&nbsp;Умнож все переменные, изменяющиеся во время игры на</span><span id=t35>&nbsp;DeltaTime.</span></p> <p><span id=t37>X:+Speed*Cos(Dir)*DeltaTime</span></p> <p><span id=t37>Y:+Speed*Sin(Dir)*DeltaTime</span></p> <p><span id=t37>Sheild:+ SheildRechargeRate*DeltaTime</span></p><span id=t37> <p><span id=t35>3. Поменяй скорость.&nbsp;Когда используешь <em>дельтатайминг</em> скорость изменяется в <em>пиксель/секунда</em>. Это значит, что если разрешение <strong>800x600</strong> и тебе нужно, чтобы ширина экрана проходилась за <strong>3</strong> секунды, скорость будет равна: <strong>800</strong>/<strong>3</strong>, <strong>800</strong> пикселей за <strong>3</strong> секунды. Эта скорость будет всегда такой, несмотря на <strong>FPS</strong>.</span></p> <p><span id=t35></span>&nbsp;</p><span id=t35> <p><b><i><span id=t36><a name=b31><b><i><span id=t36>Картинки</span></i></b></a></span></i></b></p> <p><span id=t35>&nbsp; Картинки - это быстрый и легкий способ рисования графиуи на экран. Перед тем как ты найдешь или создашь картинку, ты должен знать имя файла картинки и цвет фона(<strong>Красный: Зеленый: Голубой</strong>).&nbsp;<span id=t35><em>Maskcolor</em> - это цвет, который ты будешь использовать прозрачным. Если, например, <span id=t35>Maskcolor - черный, то все черные пиксели картинки рисоваться не будут.</span></span></span></p></span><span id=t35> <p><span id=t37>SetMaskColor 0,0,0 ‘</span></p> <p><span id=t37>Global My_Image%=Loadimage(“Имя_файла_картинки.bmp”, MaskedImage )</span></p> <p><span id=t37><span id=t35>Или тоже самое:</span></span></p> <p><span id=t37><span id=t35><span id=t37>Global My_Image:Timage=Loadimage(“Имя_файла_картинки.bmp”, MaskedImage )</span></span></span></p> <p><span id=t37><span id=t35><span id=t37><span id=t35><strong><em>Loadimage</em></strong> возвращает объект-картинку. Объект-картинка - это то, что <strong>blitz</strong> использует для хранения загруженных картинок. Этот объект указывает на адрес картинки и потом используется, когда её нужно нарисовать, или изменить. <strong><em>Loadimage</em></strong> можно писать только после инициализации графики, иначе твоя картинка будет белым прямоугольником.</span></span></span></span></span></span></span></span></span></p> <p><span id=t37>MidhandleImage( My_image ) ‘ Центрует координаты картинки.</span></p> <p><span id=t37><span id=t35>Чтобы отцентровать все картинки используй&nbsp;</span><span id=t37>Automidhandle( true)</span><span id=t35>. Эти комманды изменяют способ рисования картинок, используй их перед тем, как нарисовать картинку.</span></span></p> <p><span id=t37>Setcolor</span><span id=t35>(красный,зеленый,синий):&nbsp;Меняет цвет картинки пропорционально введенным значениям, </span></p> <p><span id=t35>белый(255,255,255) - цвет не изменяется.</span></p> <p><span id=t35><span id=t37>SetAlpha</span><span id=t35>( Alpha# ) ‘Устанавливает степень прозрачности картинки. 1 - непрозрачный, 0 - невидимый, 0.5 - полупрозрачный.</span></span></p> <p><span id=t35><span id=t35>Чтобы использовать эффекты прозрачности необходимо написать: <span id=t37>SetBlend( AlphaBlend )<font id=t45>.</font></span></span></p> <p><span id=t35>To display the transparency effect you need to </span><span id=t37>SetBlend( AlphaBlend )</span></p></span> <p><span id=t35><span id=t37>SetRotation</span><span id=t35>(&nbsp;<em>направление</em> )' Крутит картинки в реальном времени! <em>направление</em> задается в пределах 0-360(оно может быть и больше и меньше, но через каждые 360 направление будет таким-же, например:</span></span></p> <p><span id=t35><span id=t35><span id=t35><span id=t37>SetRotation</span><span id=t35>(0) и <span id=t35><span id=t37>SetRotation</span><span id=t35>(360) и <span id=t35><span id=t37>SetRotation</span><span id=t35>(720) делают одно и тоже(нормальное положение картинки)</span></span></span></span></span></span>).</span></span></p> <p> <p><span id=t35></span></p> <p><font id=t47><span id=t37>SetScale</span><span id=t35>(Scale#)' масштабирует картинку в реальном времени. <strong>1</strong>=<em>100%</em>, <strong>2</strong>=<em>200%</em>, <strong>0,5</strong>=<em>50%</em> от исходной картинки.</span></font></p> <p><span id=t39></span>&nbsp;</p> <p id=t4><span id=t39><a name=p22><span id=t39>22</span></a></span></p> <p><span id=t35>&nbsp; После загрузки картинки её можно нарисовать, используя&nbsp;<span id=t37>Drawimage</span><span id=t35>(&nbsp;<em>Твоя_картинка</em> )</span></span></p> <p><span id=t35><span id=t35>Если нужно изменить картинку в реальном времени нужно использовать <em>пиксмапы</em>(<strong><em>pixmap</em></strong>) или, если картинка уже есть,&nbsp;преобразовать картинку в пиксмап. Как, например, если ты хочешь поменять <em>цвет прозрачности</em>(maskcolor) после загрузки.</span></span></p> <p>&nbsp;</p> <p><b><i><span id=t36><a name=b32><b><i><span id=t36>Таймеры в реальном времени</span></i></b></a></span></i></b></p> <p><span id=t35>&nbsp; Таймеры, которые не остонавливают твою игру. Они нужны, когда нужно ввести ограничения по времени в игру. Скажем, тебе нужно, чтобы произошло какое-нибудь действие через 10 секунд. Чтобы получить текущее время используем <span id=t35><em><strong>millisecs()</strong></em>, которая возвращает время ЦП в милисекундах. <strong><em>Millisecs()</em></strong> возвращает <em>int</em> и увеличивается с каждой милисекундой.</span></span></p> <p><span id=t35><span id=t35>Это простой способ ввести время в игру:</span></span></p> <p><span id=t37>EndTime = Millisec()+2000 ‘Ставим “EndTime”("конечное время")&nbsp;равным&nbsp;текущему времени&nbsp;+ 2 секунды</span></p> <p><span id=t37>Repeat</span></p> <p><span id=t37>If Millisecs() &gt; EndTimer ’Если текущее время больше чем&nbsp;EndTime, то выходим:&nbsp;End</span></p> <p><span id=t37>Print “2 seconds...” ; конец</span></p> <p><span id=t37>EndIf</span></p> <p><span id=t37>Forever</span></p> <p>&nbsp;</p> <p><span id=t36><strong><em><a name=b33><span id=t36><strong><em>Анимация</em></strong></span></a></em></strong></span></p><span id=t35>&nbsp; Анимация&nbsp;в BlitzMax - это несколько картинок, загруженных одна за одной. Когда ты рисуешь картинку с анимацией тебе нужно определять какой кадр этой картинки рисовать. Это легкий способ использования анимации в игре. Нет, это не перемудрено. Чтобы создать картинку с анимацией, нужно сделать одну большую, где будут все кадры анимации. Скажем, у тебя есть&nbsp;хорошая(<font id=t50>другое слово было убрано цензурой</font>) сцена взрыва с двадцатипятью кадрами <strong><em>50x50</em></strong>.&nbsp;Ширина анимационной картинки будет <strong><em>50</em></strong>*<strong><em>25</em></strong>=<strong>1250</strong> пикселей.</span> <p><span id=t35><span id=t37>LoadAnimImage(Путь$,ширина,высота,начало,кол-во) ‘ширина,высота,начало,кол-во&nbsp;относятся к кадрам</span></span></p><span id=t35>Кадры "начинаются" с <strong>0</strong>(т.е. номер первого кадра - <strong>0</strong>), когда <em><font id=t30>кол-во</font></em> должно быть не менее <strong>1</strong>(хотя-бы 1 кадр).</span> <p><span id=t35>Вот пример загрузки такой картинки:&nbsp;&nbsp;</span></p> <p><span id=t35><span id=t37>My_Animation = LoadAnimImage(“/Gfx/Image.bmp”,25,1250,0,24)</span></span></p> <p><span id=t35>Что бы её нарисовать просто пиши: <span id=t37>DrawImage(картинка_с_анимацией,X,Y,кадр)</span></span></p><span id=t35>В <strong><em>DrawImage</em></strong> "кадр" начинается с <strong>0</strong> до <em><font id=t31>кол-во</font></em>, которое ты установил в <span id=t35><strong><em>LoadAnimImage</em></strong>.</span></span> <p>&nbsp;</p> <p><span id=t36><strong><em><a name=b34><span id=t36><strong><em>Сохраняем картинки в .exe</em></strong></span></a></em></strong></span></p> <p><span id=t35>&nbsp; В <strong>BlitzMax</strong> есть очень полезная фича - можно все внешние ресурсы в <strong><em>exe</em></strong>. Это позволяет распростронять игру только как эксешник. Это означает, что будет не нужно никаких(<font id=t50>разумеется кроме файлов конфигурации и сохранений, если такие есть</font>) внешних файлов чтобы поиграть в твою игру. Это так-же защищает твои "художества" от других(не от хака). Эту фичу очень легко использовать. Чтобы добавить файл в эксешник нужно вставить следующую строку куда-нибудь в начало кода:</span></p> <p><span id=t35><span id=t37>IncBin “directory/filename.bmp”</span></span></p> <p><span id=t35>Затем при загрузке картинки нужно писать:</span></p> <p><span id=t35><span id=t37>Loadimage( “IncBin::</span><span id=t35>directory/filename.bmp</span><span id=t37>”)</span><span id=t35>. Путь до файла может&nbsp;содержать и поддириктории, просто нужно писать писать одинаковый путь в <span id=t35><span id=t37>IncBin </span></span>и&nbsp;в загрузке. Насколько я знаю, можно подключить любой файл.</span></span></p> <p><span id=t35></span>&nbsp;</p> <p><span id=t35><span id=t36><strong><em><a name=b35><span id=t35><span id=t36><strong><em>Звуки</em></strong></span></span></a></em></strong></span></span></p> <p><span id=t35>&nbsp; Звуки загружаются так же как и картинки, <strong><em>YourSound = LoadSound(“boom.wav”)</em></strong>.</span></p> <p><span id=t35>Затем этот звук можно проиграть с помощью PlaySound(YourSound). Можно использовать разные каналы(<font id=t50>как, например левый и правый</font>). Грузить можно .ogg и&nbsp;.wav. Читай больше в описании.</span></p> <p>&nbsp;</p> <p id=t4><span id=t39><a name=p23><span id=t39>23</span></a></span></p> <p><b><i><span id=t36><a name=b36><b><i><span id=t36>Коротко о тесте на столкновения</span></i></b></a></span></i></b></p> <p><span id=t35>&nbsp;&nbsp;Тесты на столкновения проводят, чтобы определить, что что-то пересекло что-то ещё. Скажем, тебе нужно узать, попала-ли пуля во врага. Вот способ, который я&nbsp;узнал&nbsp;на форумах:</span><span id=t35>&nbsp;</p> <p><span id=t37>Function RectsOverlap(x0, y0, w0, h0, x2, y2, w2, h2)</span></p> <p><span id=t37>If x0 &gt; (x2 + w2) Or (x0 + w0) &lt; x2 Then Return False</span></p> <p><span id=t37>If y0 &gt; (y2 + h2) Or (y0 + h0) &lt; y2 Then Return False</span></p> <p><span id=t37>Return True</span></p> <p><span id=t37>End Function</span></p></span> <p><span id=t35>Эта функция проверяет на пересечение&nbsp;прямоугольник <strong>x0</strong>,<strong>y0</strong>,<strong>w0</strong>,<strong>h0</strong> и прямоугольник <font id=t45><strong>x2</strong>, <strong>y2</strong>, <strong>w2</strong>, <strong>h2</strong> и если они пересеклись, то возвращает <strong>1</strong>, если нет, то <strong>0</strong>. Работает хорошо при проверке <strong>ВРАГ</strong>x<strong>ВРАГ</strong> и <strong>МЫШКА</strong>x<strong>КНОПКА</strong>.</font></span></p> <p><span id=t35>Скажем, не нужно, чтобы люди ходили сквозь стены, но... как это сделать?</span></p> <p><span id=t35>Попробуем использовать предыдущий пример. Скажем, есть невидимая стена, у которой <em><strong>X</strong></em>=<strong>100</strong>:</span></p> <p><span id=t37>Graphics 800,600</span></p> <p><span id=t37>Global Xvel#=0.5;X#=50</span></p> <p><span id=t37>Repeat</span></p> <p><span id=t37>LastX = X ‘Сохраняем X для последующего восстановления</span></p> <p><span id=t37>X=X+Xvel ‘Обновляем&nbsp;X</span></p> <p><span id=t37>Drawrect(X,50,300,55)</span></p> <p><span id=t37>If X &gt; 500</span></p> <p><span id=t37>X=LastX ‘Столкновение, нужно восстановить сохраненную&nbsp;X</span></p> <p><span id=t37>Endif</span></p> <p><span id=t37>Until Keydown(Key_Escape)</span></p> <p><span id=t35>Это можно проделывать и&nbsp;в двух направлениях чтобы имитировать столкновения, отскоки и скольжения о поверхности. Можно обновлять все объекты в сприске и проверять их на столкновение друг с другом Но это вызовет большую затрату ресурсов ЦП, чем больше объектов проверяется - тем больше скорости забирается у игры. Способ проверки на столкновения определяется типом создоваемой игры. В <strong>Blitz</strong>&nbsp;есть встроенные функции проверки на столкновение картинок, которые позволяют проводить проверки с точностью-до-пикселя. Они сложные, так что я не советовал бы использовать их новичкам без соответствующей документации.</span></p> <p> <p><b><span id=t46></span></b>&nbsp;</p> <p></p> <p><b><span id=t46><span id=t36><em><a name=b37><b><span id=t46><span id=t36><em>Создай&nbsp;свою первую игру на&nbsp;BlitzMax </em></span></span></b></a></em></span></span></b></p> <p><span id=t35>&nbsp; Чтобы тебе начать я накатал небольшой план:</span></p><span id=t35> <p><span id=t35>1. Начни с небольшого..&nbsp;Придумай маленькую и небольшую игру.</span></p> <p><span id=t35>2. Опиши свою игру на бумаге(с картинками:)).</span></p> <p><span id=t23>3. Спланируй все функции, типы. Если это твоя первая игра, то сделай их простыми!</span></p> <p><span id=t23>4.&nbsp;Задавай на форумах любые вопросы, также, как им твой план игры.</span></p> <p><span id=t23></span><span id=t23>5. Начинай прогить! Делай много тестов. Комментируй каждый тип, функцию и метод!</span></p> <p><span id=t23>6. Если часть игры можно отделить(как, например, взрывы и&nbsp;создание карты), то создай маленький .bmx файл где можно&nbsp;его потестировать. Так больше шансов заметить баг.</span></p> <p><span id=t23>7. Не начинай второй проэкт, пока не закончишь первый.</span></p></span><span id=t23>Если появилась проблема, то попытайся разрешить её на форумах(<a href="http://www.blitzmax.com/">http://www.blitzmax.com/</a>&nbsp;,&nbsp;<u><font id=t51><a href="http://www.blitzcoder.com/">http://www.blitzcoder.com/</a></font></u>, и наш <a href="http://blitzgames.vov.ru/cgi-bin/yabb/yabb.cgi">http://blitzgames.vov.ru/cgi-bin/YaBB/YaBB.cgi</a> ). Для людей, которые могут тебе помочь важно, чтобы ты хорошо знал в чем состоит твоя проблема, так что </span> <p><span id=t37></span></p> <p>&nbsp;</p> <p id=t4><span id=t5><a name=p24><span id=t5>24</span></a></span></p> <p><span id=t23>подумай о ней, попробуй&nbsp;сократить её. Что это, ошибка компиляции, или что-то показывается не так, как ты ожидал? Проверь переменные, такие-ли они, какие должны быть? Используй <strong><em>Debugstop()</em></strong> на строке, если хочешь проверить, что она исполняется(если так, то игра тут остановится.)</span></p> <p><span id=t23></span>&nbsp;</p> <p><span id=t23><span id=t22><strong><em><a name=b38><span id=t23><span id=t22><strong><em>Улучшение этого руководства</em></strong></span></span></a></em></strong></span></span></p> <p><span id=t23>&nbsp; Если ты нашел что-либо, что можно тут&nbsp;улучшить, если есть вопросы, предложения или поправления, то пиши мне! (У меня пока&nbsp;нет своего сайта, так-что используй форумы <span id=t52><a href="http://www.blitzmax.com/">www.blitzmax.com</a></span>). Написанно мной, <strong><em>Wave~</em></strong> из <strong><em>Truplo co</em></strong>. Временная почта <span id=t52><a href="mailto:truplos@msn.com">Truplos@msn.com</a><font id=t45>. Я&nbsp;собираюсь улучшать этот документ, если вы напишете мне. Ошибки правописания и&nbsp;построения предложений&nbsp;тоже учитываются.</font></span></span></p> <p><span id=t23><span id=t52><font id=t25>Желаю&nbsp;хорошо провести время и удачного кодинга!</font></span></span></p> <p>&nbsp;</p> <p><span id=t23><span id=t23><span id=t22><strong><em><a name=b39><span id=t23><span id=t23><span id=t22><strong><em>Кто перевел</em></strong></span></span></span></a></em></strong></span></span></span></p> <p><span id=t23><span id=t23><span id=t22><strong><em>&nbsp; </em></strong></span></span></span><span id=t23>Перевод наконец-то закончен! Теперь всем, не знающим(или плохо знающим) буржуйский язык&nbsp;будет легче разобраться с <strong>BlitzMax</strong>. Надеюсь помог. Пишите мне, если есть вопросы.. бла-бла-бла.. и просто, пишите. Буду рад.</span></p> <p>&nbsp;</p> <p><span id=t23><strong><em>Имя с фамилией:</em></strong> Солодовниченко Михаил</span></p> <p><span id=t23><span id=t23><strong><em>Мыло:</em></strong>&nbsp;<a href="mailto:maniak_dobrii@list.ru">MANIAK_dobrii@list.ru</a></span></span></p> <p><span id=t23><span id=t23><span id=t23><strong><em>Заходите на мой сайт:</em></strong>&nbsp;<a href="http://www.maniak-dobrii.nm.ru/">http://www.maniak-dobrii.nm.ru/</a></span></span></span></p> <p>&nbsp;</p> <p><span>&nbsp;<font id=t34><strong><em>УДАЧИ!</em></strong></font></span></p></font></font></font></font></td></tr></tbody></table></body></html>